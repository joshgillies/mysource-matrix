<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Open Source Licence                                      |
* +--------------------------------------------------------------------+
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +--------------------------------------------------------------------+
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +--------------------------------------------------------------------+
*
* $Id: design_area_edit_fns.inc,v 1.47.2.2 2005/07/04 04:43:31 pgannavarapu Exp $
*
*/


require_once SQ_INCLUDE_PATH.'/asset_edit/asset_edit_fns.inc';

/**
* Design_Area_Edit_Fns
*
* Purpose
*
*
* @author  Blair Robertson <blair@squiz.net>
* @version $Revision: 1.47.2.2 $
* @package MySource_Matrix_Packages
* @subpackage __core__
*/
class Design_Area_Edit_Fns extends Asset_Edit_Fns
{

	/**
	* @var string
	* The prefix for tags in parse files
	*/
	var $tag_name = 'MySource';


	/**
	* Contructor
	*
	*/
	function Design_Area_Edit_Fns()
	{
		$this->static_screens['details']['lock_type'] = 'parsing';

	}//end constructor


	/**
	* Echo the Design Area's ID name
	*
	* @param object Asset				$asset	the asset whose interface we are painting
	* @param object	Backend_Outputter	$o		the outputter class
	* @param string						$prefix	prefix for the form element
	*
	* @return void
	* @access public
	*/
	function paintIdName(&$asset, &$o, $prefix)
	{
		echo $asset->attr('id_name');
		return true;

	}//end paintIdName()


	/**
	* Parse the string into an array recursively cut up into html and tag pieces
	*
	* @param string	$file_contents		the contents to parse
	*
	* @return Array
	* @access private
	*/
	function _parseString($file_contents)
	{
		// lets just make sure that they are all UNIX new lines
		$file_contents = str_replace(Array("\r\n", "\r"), "\n", $file_contents);

		// replace any image roots with a print operation for the image prefix
		$e = '|mysource_files\/([a-zA-Z0-9\._\-]+)|i';
		$file_contents = preg_replace($e, '<'.$this->tag_name.'_PRINT id_name=\'__global__\' var=\'file_path\' filename=\'\\1\' />', $file_contents);

		// replace any css roots with a print operation for the css prefix
		$e = '|mysource_css\/([a-zA-Z0-9\._\-]+)|i';
		$file_contents = preg_replace($e, '<'.$this->tag_name.'_PRINT id_name=\'__global__\' var=\'css_path\' filename=\'\\1\' />', $file_contents);

		// replace any './[folder/filename]' with '[folder/filename]'
		$e = '/(<link[^>]*href=")\\.\\//i';
		$file_contents = preg_replace($e, '\\1', $file_contents);

		// lets just make sure they aren't trying to be tricky and do some processing we don't know about
		$file_contents = preg_replace('|\<\?(?!xml)(.+?)(?=\?\>)\?\>|', '&lt;?\\1?&gt;', $file_contents);
		$file_contents = preg_replace('|\<\?(?=xml)(.+?)(?=\?\>)\?\>|', '<?php echo "<"."?"; ?>\\1<?php echo "?".">"; ?>', $file_contents);

		// Lets make all occurances of the open cnd close tags the
		// same case as the constant just to make it easier to parse
		$file_contents = preg_replace('/<'.$this->tag_name.'/i', '<'.$this->tag_name, $file_contents);
		$file_contents = preg_replace('/<\\/'.$this->tag_name.'/i', '</'.$this->tag_name, $file_contents);

		// create the super array from the tags
		$cur_pos    = 0;
		$nest_level = 0;
		$contents = $this->_parseStringContents($file_contents, $cur_pos, $nest_level);
		if (!is_null($contents)) {
			$this->_parserCleanupContents($contents);
		}

		return $contents;

	}//end _parseString()


	/**
	* Take the raw contents passed in and create individual elements for each
	* section of the contents (HTML or this->tag_name tag)
	* if code is nested between open and terminate tags this function is called
	* recursivley
	*
	* @param string	$file_contents	the raw contents to parse file
	* @param int	$cur_pos		the current position in $file_contents that we are
	* @param int	$cur_pos		the current position in $file_contents that we are
	*
	* @returns Array
	* @access private
	*/
	function _parseStringContents(&$file_contents, &$cur_pos, &$nest_level)
	{
		$start_pos = $cur_pos;
		$parsed = Array();
		$tag    = Array(); // the currently processed tag

		$is_nested = ($nest_level > 0);

		while ($next_tag = $this->_tagToParse($file_contents, $cur_pos)) {
			// append the string before this current pos to the array
			$parsed[]  =  Array(
							'_type'		=> 'HTML',
							'contents'	=> substr($file_contents, $start_pos, $cur_pos - $start_pos),
						  );

			if ($next_tag == 'terminate') {
				// if this instance is nested then we have found our parents end tag
				if ($is_nested) {
					// hey we found a terminate tag so decrement the nest counter
					$nest_level--;
					return $parsed;
				// else are in the root level and we have found a stray ternminate tag
				// so remove it
				} else {
					$this->_parseTerminateTag($file_contents, $cur_pos);
				}

			// its an open tag
			} else {

				$tag = $this->_parseOpenTag($file_contents, $cur_pos);

				// if this tag terminates then blank array for it's contents
				if ($tag['self_terminating']) {
					$tag['contents'] = Array();

				// else this tag doesn't terminate the we need to allow for its contents
				} else {
					$this_nest_level = $nest_level;
					// because we are going to the next level increment
					$nest_level++;
					$tag['contents'] = $this->_parseStringContents($file_contents, $cur_pos, $nest_level);
					// if something went wrong, bail out
					if (is_null($tag['contents'])) return null;

					// if this instance of the functions nest level is the same as the global one
					// then the recursive call found e terminate tag, so remove it
					if ($this_nest_level == $nest_level) {
						$this->_parseTerminateTag($file_contents, $cur_pos);

					// else we're missing a terminate tag, so die screaming
					} else {
						$die_str = $this->tag_name;
						$die_str .= (empty($tag['operation'])) ? '' : '_'.$tag['operation'];

						foreach ($tag['attributes'] as $name => $value){
							$die_str .= ' '.$name.'="'.$value.'"';
						}

						trigger_localised_error('CORE0213', E_USER_WARNING, $this->tag_name, $die_str);
						return null;

					}// end if
				}// end if

				$parsed[]  = $tag;

			} //end if if next tag

			// end parsing the tag

			$start_pos = $cur_pos;

		}// end while

		// if this instance opf the funciton is not nested
		// then it must be the root level
		if (!$is_nested) {
			// so append the rest of the html code to the array
			$parsed[] = Array(
							'_type'		=> 'HTML',
							'contents'	=> substr ($file_contents, $cur_pos),
						);

		}//end if

		return $parsed;

	}//end _parseStringContents()


	/**
	* Figure out which type of tag (open or terminate) comes next in the text
	*
	* Returns the type and sets the current position to the start of the tag
	*
	* @param string	$file_contents	the raw contents to parse file
	* @param int	$cur_pos		the current position in $file_contents that we are
	*
	* @return string
	* @access private
	*/
	function _tagToParse(&$file_contents, &$cur_pos)
	{
		// get the next terminate and open tag locations
		$next_open_pos      = strpos($file_contents, '<'.$this->tag_name,  $cur_pos);
		$next_open_tag      = ($next_open_pos !== false);
		$next_terminate_pos = strpos($file_contents, '</'.$this->tag_name, $cur_pos);

		// if there is a terminate tag
		if ($next_terminate_pos !== false) {
			// if there is no open tag
			// or if there is a open tag and its located after the terminate tag
			// then parse the terminate tag
			if (!$next_open_tag || ($next_open_tag && ($next_terminate_pos < $next_open_pos))) {
				$cur_pos = $next_terminate_pos;
				return 'terminate';
			}
		}

		// if there is a open tag then use it
		if ($next_open_tag) {
			$cur_pos = $next_open_pos;
			return 'open';
		}

		// if they got this far there isn't anything left
		return '';

	}//end _tagToParse()


	/**
	* Parse all the info from the start of the open tag until its end
	*
	* Also assigns any attributes that the tag may have contained
	*
	* @param string	$file_contents	the raw contents to parse file
	* @param int	$cur_pos		the current position in $file_contents that we are
	*
	* @return array
	* @access private
	*/
	function _parseOpenTag(&$file_contents, &$cur_pos)
	{
		$cur_pos += strlen('<'.$this->tag_name);

		$in_quote     = '';
		$escape_slash = false;

		$currently_getting = '';  // 'name' or 'value'
		$current_name  = '';      // attribute name
		$current_value = '';      // attribute value

		// used to reverse any HTML encoding that has taking place
		$trans = array_flip(get_html_translation_table(HTML_ENTITIES));

		$tag = Array('_type' => 'TAG', 'attributes' => Array());

		// if the next character is an underscore then we have a special operation tag
		if ($file_contents{$cur_pos} == '_') {
			$cur_pos++;
			$tag['operation'] = '';
			// while this isn't the end of the tag and it's not some white space,
			// append to operation
			while ($file_contents{$cur_pos} != '>' && !$this->_isWhitespace($file_contents{$cur_pos})) {
				$tag['operation'] .= $file_contents{$cur_pos};
				$cur_pos++;

			}//end while

			$tag['operation'] = strtolower($tag['operation']);

		}//end if specific operation

		while ($file_contents{$cur_pos} != '>' || $in_quote) {

			$escape_slash = (!$in_quote && $file_contents{$cur_pos} == '/');
			if (!$escape_slash) {
				// if we are not currenly getting any thing and we happen to fall upon
				// a non-whitespace charater then let's assume its an attribute name
				// and start getting it
				if (!$currently_getting && !$this->_isWhitespace($file_contents{$cur_pos})) {
					$currently_getting = 'name';
				}


				if ($currently_getting == 'name') {
					// if this is the equals sign then time to change to getting the value
					if ($file_contents{$cur_pos} == '=') {
						$currently_getting = 'value';
						$current_value = '';

					// if its whitespace then they fucked up so discard this name
					} else if ($this->_isWhitespace($file_contents{$cur_pos})) {
						$currently_getting = '';
						$current_name = '';
					// must be a character, append to name
					} else {
						$current_name .= $file_contents{$cur_pos};
					}

				} else if ($currently_getting == 'value') {

					// if the current value is blank, we are not in a quote and this char is a quote
					// then we must be starting a new value
					$is_quote = ($file_contents{$cur_pos} == '\'' || $file_contents{$cur_pos} == '"');
					if (!$current_value && !$in_quote && $is_quote) {
						$in_quote = $file_contents{$cur_pos};

					// if we're not in a quote, then this value doesn't have quotes around it
					// so just keep going until we hit some whitespace
					} else if (!$in_quote && !$this->_isWhitespace($file_contents{$cur_pos})) {
						$current_value .= $file_contents{$cur_pos};

					// if we are in a quote and this char is not that quote, append
					} else if ($in_quote && $file_contents{$cur_pos} != $in_quote) {
						$current_value .= $file_contents{$cur_pos};

					// else we are either not in a quote and have hit some white space
					// or we are in a quote and have found a another quote of the same char
					// SO, we have finished this value, assign to tag and start over
					} else {
						$tag['attributes'][strtolower($current_name)] = strtr($current_value, $trans);
						$currently_getting = '';
						$current_name = '';
						$current_value = '';
						$in_quote = '';

					}// end if

				}// end if

			}//end if not escape slash


			$cur_pos++;

		}//end while
		$cur_pos++;

		// if the last char before the close bracket is an foreslash
		// then this tag does not have a matching termination tag
		$tag['self_terminating'] = $escape_slash;

		return $tag;

	}//end _parseOpenTag()


	/**
	* Keep counting the characters until we hit a close bracket
	*
	* @param string	$file_contents	the raw contents to parse file
	* @param int	$cur_pos		the current position in $file_contents that we are
	*
	* @access private
	*/
	function _parseTerminateTag(&$file_contents, &$cur_pos)
	{
		$cur_pos += strlen('</'.$this->tag_name);
		// go to the next close bracket
		$cur_pos = strpos($file_contents, '>', $cur_pos);
		// go to char after it
		$cur_pos++;

	}//end _parseTerminateTag()


	/**
	* Return true if the whole string is whitespace of somekind
	*
	* @param string	$str
	*
	* @return boolean
	* @access private
	*/
	function _isWhitespace($str)
	{
		return preg_match('/^[[:space:]]*$/', $str);

	}//end _isWhitespace()


	/**
	* Recurses through the contents array and removes any HTML tags contain only whitespace
	* and are set between two tags
	*
	* @param array	$contents	the contents array we are currently checking
	*
	* @access private
	*/
	function _parserCleanupContents(&$contents)
	{
		for ($i = 0; $i < count($contents); $i++) {
			if ($contents[$i]['_type'] == 'HTML' && $this->_isWhitespace($contents[$i]['contents'])) {
				array_splice($contents, $i, 1);
				$i--;
			} else if ($contents[$i]['_type'] == 'TAG' && !empty($contents[$i]['contents'])) {
				$this->_parserCleanupContents($contents[$i]['contents']);
			}// end if
		}// end for

	}//end _parserCleanupContents()


	/**
	* Loop through the contents array and create the necessary objects
	*
	* @param object Asset	$asset		the asset to which we belong
	* @param array			$contents	the contents array we generated with _parseString()
	*
	* @return boolean
	* @access private
	*/
	function _processContents(&$asset, $contents)
	{
		if ($this->_setVariables($asset, $contents)) {
			$GLOBALS['SQ_PROCESSED_DESIGN_AREAS'][$asset->attr('id_name')] = true;
			return $asset->setAttrValue('contents', $contents);
		} else {
			return false;
		}

	}//end _processContents()


	/**
	* Takes the reference to the tag array passed into created by _parseStringContents()
	* and sets both the attributes and sets operation tags into values
	* the set tags are then removed from the array
	*
	* Also anything with 'image' contained in it will have the file root removed
	* from its value
	*
	* @param object Asset	$asset		the asset to which we belong
	* @param array			$contents	the contents array from _parseString
	*
	* @access private
	* @return boolean
	*/
	function _setVariables(&$asset, &$contents)
	{
		// process the set operations of the element
		$remove_indexes = Array();
		// Holds all attributes that have been set in the parse file for this design area
		$set_attrs = Array();
		$var_references = Array();
		foreach ($contents as $index => $element) {

			if ($element['_type'] != 'TAG' || $element['operation'] != 'set') {
				continue;
			}

			// Is this a reference to another variable ?
			if (!empty($element['attributes']['id_name']) && !empty($element['attributes']['var'])) {

				// just set this so we remember what is happening when it comes to painting
				$var_references[$element['attributes']['name']] = Array(
																	'id_name'	=> $element['attributes']['id_name'],
																	'var'		=> $element['attributes']['var'],
																  );

			// Do we want a whole design areas value ?
			} else if (!empty($element['attributes']['id_name'])) {

				// just set this so we remember what is happening when it comes to painting
				$var_references[$element['attributes']['name']] = Array(
																	'id_name'	=> $element['attributes']['id_name'],
																	'var'		=> '',
																  );

			// we must be a normal value, so set it
			} else if (isset($element['attributes']['value'])) {
				// if this holds an image, then remove any image roots before saving
				if (stristr($element['attributes']['name'], 'image')) {
					$element['attributes']['value'] = $this->_removeFileRoot($element['attributes']['value']);
				}

				if (!$asset->setAttrValue($element['attributes']['name'], $element['attributes']['value'])) {
					trigger_localised_error('CORE0189', E_USER_WARNING, $element['attributes']['name'], $asset->attr('id_name'));
					return false;
				}
				$set_attrs[] = $element['attributes']['name'];
			// else something is amiss and we don't know what we can do, so barf in their direction
			} else {
				trigger_localised_error('CORE0188', E_USER_WARNING, $element['attributes']['name'], $asset->attr('id_name'));


			}// endif

			$remove_indexes[] = $index;

		}//end foreach

		if (!$asset->setAttrValue('var_references', $var_references)) {
			return false;
		}

		// Now remove the elems
		// reverse the order so we don't throw the numbers out of whack by removing one from the start
		rsort($remove_indexes, SORT_NUMERIC);
		foreach ($remove_indexes as $i) {
			array_splice($contents, $i, 1);
		}

		// Now we need to ensure that any attributes that weren't set in the parse file
		// are returned to their default values

		// Design Area attributes that shouldn't be reset
		$not_setable_attrs = $GLOBALS['SQ_SYSTEM']->am->getAssetTypeAttributes('design_area', Array('name'));

		// add any attributes that shouldn't be set to default here
		$additional_attrs = Array('asset_contents', 'divider_contents', 'type_codes', 'settings');
		$current_asset_attrs = $GLOBALS['SQ_SYSTEM']->am->getAssetTypeAttributes($asset->type(), Array('name'));

		// Now compute the remaining attributes, by subtracting all that shouldn't be deleted
		// and all that are set in the parse file
		$set_to_default = array_diff($current_asset_attrs, $not_setable_attrs, $set_attrs, $additional_attrs);

		// Now iterate through each variable that is setable and doesn't exist in the design file,
		// find and retrieve its attribute and set its current value to the default
		foreach ($set_to_default as $i => $attr_name) {
			$attr_to_set =& $GLOBALS['SQ_SYSTEM']->am->getAttribute($asset->vars[$attr_name]['attrid']);
			$asset->setAttrValue($attr_name, $attr_to_set->_default_value);
			$attr_to_set = null;
		}

		return true;

	}//end _setVariables()


	/**
	* Remove any image roots from the front of the string
	*
	* Replace any './[folder/filename]' with '[folder/filename]'
	*
	* @param string	$str	the string to remove any image root from
	*
	* @return string
	* @access private
	*/
	function _removeFileRoot($str)
	{
		return preg_replace('/^(\\.\\/)?mysource_files\/(.*)/i', '\\2', $str);

	}//end _removeFileRoot()


	/**
	* Returns a default contents for the passed type
	* Can be used when there is no contents supplied in parse file
	*
	* @param object Asset	$asset			the asset to which we belong
	* @param string			$content_type	the name that forms the filename 'default_'.$content_type.'_contents.html'
	*										in the asset types directory
	*
	* @return Array()
	* @access private
	* @see _parseString();
	* @see _processContents();
	*/
	function _getDefaultContents(&$asset, $content_type)
	{
		$parent_types = $asset->getTypeAncestors(false);
		array_unshift($parent_types, $asset->type());
		for ($i = 0, $total = count($parent_types); $i < $total; $i++) {

			$file = SQ_SYSTEM_ROOT.'/'.$GLOBALS['SQ_SYSTEM']->am->getTypeInfo($parent_types[$i], 'dir').'/default_'.$content_type.'_contents.html';
			if (file_exists($file)) {
				require_once SQ_FUDGE_PATH.'/general/file_system.inc';
				$contents = $this->_parseString(file_to_string($file));
				return $contents;
			}//	end if

			// we don't need to go any higher than this class
			if ($parent_types[$i] == 'design_area') break;

		}// end for

		return Array();

	}//end _getDefaultContents()


	/**
	* Output the PHP/HTML code that will hopefully form part of the creating the design file
	*
	* @param Array			$contents	the parse contents to use in the output
	* @param object Asset	$asset		the asset to which we belong
	* @param object Design	$design		the design object that is painting us
	*
	* @return boolean
	* @access private
	*/
	function _createDesignFileOutput($contents, &$asset, &$design)
	{
		return $this->_outputContents($contents, $asset, $design);

	}//end _createDesignFileOutput()


	/**
	* Outputs the PHP/HTML code that will hopefully form part of the creating the design file
	*
	* @param Array			$contents	the parse contents to use in the output
	* @param object Asset	$asset		the asset to which we belong
	* @param object Design	$design		the design object that is painting us
	*
	* @return boolean
	* @access private
	*/
	function _outputContents($contents, &$asset, &$design)
	{
		// right, just loop over the contents and output each of the elements
		foreach ($contents as $index => $element) {

			if ($element['_type'] == 'HTML') {
				echo $element['contents'];
			} else {
				if (!$this->_outputElement($element, $asset, $design)) {
					return false;
				}
			}// end if

		}// end foreach

		return true;

	}//end _outputContents()


	/**
	* Used by _outputContents() to deal with a print tag
	*
	* @param array			$element	the print element tag
	* @param object Asset	$asset		the asset to which we belong
	* @param object Design	$design		the design object that is painting us
	*
	* @return boolean
	* @access private
	* @see _outputContents()
	*/
	function _outputElement($element, &$asset, &$design)
	{
		switch ($element['operation']) {
			case 'print' :
				// if there isn't a id_name we are using the current asset
				if (empty($element['attributes']['id_name']) && empty($element['attributes']['var'])) {
					$attr_str = '';
					foreach ($element['attributes'] as $k => $v) {
						$attr_str .= $k.'="'.$v.'"';
					}
					trigger_localised_error('CORE0171', E_USER_WARNING, $attr_str);
					return false;
				}

				// if there isn't a id_name we are using the current asset
				if (empty($element['attributes']['id_name'])) {
					$id_obj = &$asset;

				// this is the global design var ?
				} else if ($element['attributes']['id_name'] == '__global__') {
					$id_obj = &$design;

				// otherwise we have to find the design area
				} else {
					$id_obj = &$design->getDesignArea($element['attributes']['id_name']);
					if (is_null($id_obj)) {
						trigger_localised_error('CORE0153', E_USER_WARNING, $element['attributes']['id_name']);
						return false;
					}
				}

				// if there is no var then print the asset
				if (empty($element['attributes']['var'])) {
					// we don't want recursion, so only print if the id_obj is not the asset
					if ($id_obj !== $asset) {
						if (!$id_obj->printArea($design)) return false;
					}
				} else {
					$args = $element['attributes'];
					unset($args['id_name']);
					unset($args['var']);
					$id_obj->printVar($element['attributes']['var'], $args);
				}// endif

				return true;

			default :
				trigger_localised_error('CORE0175', E_USER_WARNING, $element['operation']);
				return false;

		}// end switch

	}//end _outputElement()


	/**
	* Create a string that is able to be parsed to recreate this design area in its current form
	*
	* @param object Asset	$asset	the asset whose interface we are painting
	*
	* @return boolean
	* @access public
	*/
	function createParseString(&$asset)
	{
		$text = '';
		$vars = $this->getSetableVars($asset);
		require_once SQ_FUDGE_PATH.'/general/general.inc';
		foreach ($vars as $name => $data) {
			$text .= '<'.$this->tag_name.'_SET name="'.$name.'"';

			// if this is this a var reference ?
			if (!empty($asset->vars['var_references']['value'][$name])) {
				$text .= ' id_name="'.htmlentities($asset->vars['var_references']['value'][$name]['id_name']).'" var="'.htmlentities($asset->vars['var_references']['value'][$name]['var']).'"';
			} else {
				$text .= ' value="'.htmlentities_array($data['value']).'"';
			}
			$text .= " />\n";
		}

		foreach ($asset->vars['contents']['value'] as $data) {
			switch ($data['_type']) {
				case 'HTML' :
					$text .= $data['contents'];
				break;
				case 'TAG' :
					$text .= '<'.$this->tag_name.'_'.strtoupper($data['operation']);
					foreach ($data['attributes'] as $k => $v) {
						$text .= ' '.$k.'="'.htmlentities($v).'"';
					}
					$text .= ' />';
				break;
			}// end switch
		}// end foreach

		#pre_echo($text);

		return $text;

	}//end createParseString()


	/**
	* Returns an array of vars that are setable, used to create the parseString
	*
	* @param object Asset	$asset	the asset whose interface we are painting
	*
	* @return Array
	* @access public
	* @see createParseString()
	*/
	function getSetableVars(&$asset)
	{
		$vars = $asset->vars;
		unset($vars['id_name']);
		unset($vars['contents']);
		unset($vars['var_references']);
		unset($vars['specialised']);
		return $vars;

	}//end getSetableVars()


	/**
	* Paint the interface for the specialising this design area
	*
	* @param object Asset				$asset	the asset whose interface we are painting
	* @param object	Backend_Outputter	$o		the outputter class
	* @param string						$prefix	prefix for the form element
	*
	* @return boolean
	* @access public
	*/
	function paintSpecialisation(&$asset, &$o, $prefix)
	{
		if (!$asset->writeAccess('parsing')) return;
		$text = $this->createParseString($asset);
		hidden_field($prefix.'_specialisation_orig', $text);
		text_area($prefix.'_specialisation', $text, 75, 20, 0, 'wrap="off" style="font-family: courier new, courier, monospace; font-size: 9pt;"');

	}//end paintSpecialisation()


	/**
	* Process the specialisation, ie call _parseString() and set the specialised flag to true
	*
	* @param object Asset				$asset	the asset to which we belong
	* @param object	Backend_Outputter	$o		the outputter class
	* @param string						$prefix	prefix for the form element
	*
	* @return boolean
	* @access public
	*/
	function processSpecialisation(&$asset, &$o, $prefix)
	{
		// if nothing changed then do nothing
		if ($_POST[$prefix.'_specialisation_orig'] == $_POST[$prefix.'_specialisation']) {
			return false;
		}

		#pre_echo($_POST[$prefix.'_specialisation']);
		$contents = $this->_parseString($_POST[$prefix.'_specialisation']);
		#pre_echo($contents);
		if (!is_null($contents) && $this->_processContents($asset, $contents)) {
			#pre_echo("PROCESS OK");
			return $asset->setAttrValue('specialised', 1);
		}

		return false;

	}//end processSpecialisation()


}//end class

?>
