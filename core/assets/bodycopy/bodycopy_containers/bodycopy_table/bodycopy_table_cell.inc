<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Open Source Licence                                      |

* +--------------------------------------------------------------------+
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +--------------------------------------------------------------------+
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +--------------------------------------------------------------------+
*
* $Id: bodycopy_table_cell.inc,v 1.10.2.1 2004/12/09 03:17:24 gsherwood Exp $
* $Name: not supported by cvs2svn $
*/


/**
* Bodycopy_Table_Cell
*
* Purpose
*
*
* @author  Greg Sherwood <greg@squiz.net>
* @version $Version$ - 1.0
* @package MySource_Matrix_Packages
* @subpackage __core__
*/
class BodyCopy_Table_Cell extends MySource_Object
{

	var $attributes = Array(); // an array of attributes for the TD tag

	/**
	* Constructor
	*
	*/
	function BodyCopy_Table_Cell()
	{
		parent::MySource_Object();

	}//end constructor


	/**
	* Sets an attribute value in the attributes var
	* Internal checking of these attributes goes here
	*
	* @param string	$name	the name of the attribute
	* @param string	$value	the value of the attribute
	*
	* @return boolean
	* @access public
	*/
	function setAttribute($name, $value)
	{
		$name = strtolower($name);
		if (!isset($this->attributes[$name])) $this->attributes[$name] = '';
		if ($this->attributes[$name] == $value) return false;
		$this->attributes[$name] = $value;
		return true;

	}//end setAttribute()


	/**
	* Sets the type of the cells content for editing
	*
	* @param object BodyCopy_Table	&$table	the table object
	* @param string					$type	the type of the cells content
	* @param integer				$rowid	the row the cell is in
	* @param integer				$cellid	the id of the cell
	*
	* @return boolean
	* @access public
	*/
	function setContentType(&$table, $type, $rowid, $cellid)
	{
		$GLOBALS['SQ_SYSTEM']->am->includeAsset($type);
		$content_link = Array('asset' => &$table, 'link_type' => SQ_LINK_TYPE_2, 'is_dependant' => 1, 'is_exclusive' => 1);
		$content_type = new $type();
		$content_type->setAttrValue('name', 'Row '.($rowid+1).' Cell '.($cellid+1));
		$this->attributes['linkid'] = $content_type->create($content_link);
		if (!$this->attributes['linkid']) return false;
		$this->attributes['content_type'] = $type;
		return true;

	}//end setContentType()


	/**
	* Update the link between the cells contentType and the table
	* From time to time it may be nescessary to add or remove rows or columns.
	* We need to make sure when any change happens in the table that the
	* name remains relevant to where the cell is in the table.
	*
	* @param object BodyCopy_Table	&$table	the table object
	* @param integer				$new_rowid	the row the cell is going in
	* @param integer				$new_cellid	the column the cell is going in
	*
	* @return boolean
	* @access public
	*/
	function updateContentType(&$table, $new_rowid, $new_cellid)
	{
		$link = $GLOBALS['SQ_SYSTEM']->am->getLinkById($this->attributes['linkid'], $table->id);
		if (!$content_type = &$GLOBALS['SQ_SYSTEM']->am->getAsset($link['minorid'], $link['minor_type_code'])) return false;
		if (!$content_type->setAttrValue('name', 'Row '.($new_rowid+1).' Cell '.($new_cellid+1))) return false;
		if (!$content_type->saveAttributes()) return false;
		return true;

	}//end updateContentType()


	/**
	* Delete this bastard
	*
	* @param object BodyCopy_Table	&$table	the table object
	*
	* @return boolean
	* @access public
	*/
	function delete(&$table)
	{
		if (!$table->deleteLink($this->attributes['linkid'])) return false;
		unset($this->attributes);
		$this = new BodyCopy_Table_Cell();
		return true;

	}//end delete()


	/**
	* How many columns does this cell span ??
	*
	* @return integer
	* @access public
	*/
	function colspan()
	{
		if (empty($this->attributes['colspan'])) return 1;
		return ((int) $this->attributes['colspan'] > 0) ? (int) $this->attributes['colspan'] : 1;

	}//end colspan()


	/**
	* How many rows does this cell span ??
	*
	* @return integer
	* @access public
	*/
	function rowspan()
	{
		if (empty($this->attributes['rowspan'])) return 1;
		return ((int) $this->attributes['rowspan'] > 0) ? (int) $this->attributes['rowspan'] : 1;

	}//end rowspan()


	/**
	* Prints the content of this cell complete with TD tag
	*
	* @param object BodyCopy_Table	&$table		the table object
	* @param string					$prefix		prefix for form elements
	* @param boolean				$editing	are we printing an editing interface
	* @param boolean				$generating	are we generating the content file
	*
	* @return void
	* @access public
	*/
	function paint(&$table, $prefix='', $editing=false, $generating=false)
	{
		if (!isset($this->attributes['linkid'])) return;

		$link = $GLOBALS['SQ_SYSTEM']->am->getLinkById($this->attributes['linkid'], $table->id);
		if (!empty($link)) {
			$content_type = &$GLOBALS['SQ_SYSTEM']->am->getAsset($link['minorid'], $link['minor_type_code']);
		} else {
			$content_type = null;
		}
		$content_prefix = $prefix.'_content_type_'.$this->attributes['content_type'].'_'.$this->attributes['linkid'];

		echo "\t\t<td";
		foreach ($this->attributes as $name => $val) {
			if ($val == '') continue;
			if ($name == 'linkid') continue;
			if ($name == 'content_type') continue;
			// if we're in edit mode, we don't want to colspan anything at all; the colspan
			// is handled by outer wrapping divs
			if (($name == 'colspan') && $editing && $table->writeAccess('content')) continue;
			if (strtolower($name) == 'nowrap') {
				if ($val) echo ' nowrap';
			} else {
				echo ' '.$name.'="'.str_replace('"', '&quot;', $val).'"';
			}
		}
		if ($editing && $table->writeAccess('content')) {
			echo ' style="margin: 2px; vertical-align:top;" id="'.$content_prefix.'_cell"';
		}
		echo ">\n";

		if (is_null($content_type)) {
			echo 'Content Type Asset Id : #'.$link['minorid'].' not found<br>Please contact your system administrator';
		} else {
			$content_edit = &$content_type->getEditFns();
			if (!empty($prefix)) {
				$content_edit->paintBackend($content_type, $content_prefix);
			} else {
				ob_start();
				$content_edit->paint($content_type, $content_prefix, $editing, $generating);
				$cell_content = ob_get_contents();
				ob_end_clean();

				// format contents for pretty HTML
				$cell_content = preg_replace("/^/", "\t\t\t", $cell_content);
				$cell_content = preg_replace("/\n/", "\n\t\t\t", $cell_content);
				echo $cell_content;
			}
		}
		echo "\n\t\t</td>\n";

	}//end paint()


	/**
	* Prints the backend interface for this table cell
	*
	* @param object BodyCopy_Table	&$table	the table object
	* @param string					$prefix		prefix for form elements
	* @param int					$tableid	the id of the table this cell is in
	* @param int					$rowid		the id of the row this cell is in
	* @param int					$cellid		the id of this cell
	*
	* @return boolean
	* @access public
	*/
	function paintCell(&$table, $prefix, $tableid, $rowid, $cellid)
	{
		$attribute_list = '';
		$colspaning = 0;
		foreach ($this->attributes as $name => $val) {
			if ($val == '') continue;
			if (strtolower($name) == 'nowrap') {
				if ($val) $attribute_list .= ' nowrap';
			} else {
				if (strtolower($name) == 'colspan') {
					$colspaning = $val;
				}
				$attribute_list .= ' '.$name.'="'.str_replace('"', '&quot;', $val).'"';
			}
		}

		// print out the edit buttons
		
		print_bodycopy_icon("Javascript: bodycopy_edit_table_cell_properties('$prefix', $tableid, $rowid, $cellid);", 'Edit Cell '.($cellid + 1).' - '.($rowid+1).'\'s Properties', (($attribute_list) ? 'Current Properties :<br>'.$attribute_list : ''), 'cell_properties', '[Edit Cell Properties]');

		$link = $GLOBALS['SQ_SYSTEM']->am->getLinkById($this->attributes['linkid'], $table->id);
		if (!empty($link)) {
			$content_type = &$GLOBALS['SQ_SYSTEM']->am->getAsset($link['minorid'], $link['minor_type_code']);
		} else {
			$content_type = null;
		}

		if (!is_null($content_type)) {
			$content_edit = &$content_type->getEditFns();
			$content_prefix = $prefix.'_content_type_'.$this->attributes['content_type'].'_'.$this->attributes['linkid'];
			$content_edit->paintBackendIcons($content_type, $content_prefix);
		}
		
		return true;

	}//end paintCell()


	/**
	* Process the backend interface for this table cell
	*
	* @param object BodyCopy_Table	&$table		the table object
	* @param string					$prefix		prefix for form elements
	* @param integer				$tableid	the id of the table this cell is in
	* @param integer				$rowid		the id of the row this cell is in
	* @param integer				$cellid		the id of this cell
	* @param array					$bc_saved	any saved changes that were performed without committing
	*
	* @return boolean
	* @access public
	*/
	function processCell(&$table, $prefix, $tableid, $rowid, $cellid, $bc_saved)
	{
		$updated = false;

		// update the contentType
		$link = $GLOBALS['SQ_SYSTEM']->am->getLinkById($this->attributes['linkid'], $table->id);
		if (empty($link)) return false;
		$content_type = &$GLOBALS['SQ_SYSTEM']->am->getAsset($link['minorid'], $link['minor_type_code']);
		$content_edit = $content_type->getEditFns();
		$content_prefix = $prefix.'_content_type_'.$this->attributes['content_type'].'_'.$this->attributes['linkid'];
		if ($content_edit->processBackend(Array(), $content_type, $content_prefix)) $updated = true;
		if (!$content_type->saveAttributes()) return false;

		if (isset($bc_saved[$prefix][$tableid]['rows'][$rowid]['cells'][$cellid]['attributes'])) {
			foreach ($bc_saved[$prefix][$tableid]['rows'][$rowid]['cells'][$cellid]['attributes'] as $name => $value) {
				if ($name == 'type') {
					// changing the content type of this cell
					if ($this->_updateCellType($table, $value)) $updated = true;
					continue;
				}
				if ($this->setAttribute($name, $value)) $updated = true;
			}
		}
		return $updated;

	}//end processCell()


	/**
	* Change the type of this cell to the passed content type
	*
	* @param object BodyCopy_Table	&$table		the table object
	* @param string					$new_type	the name of the new cell type
	*
	* @return boolean
	* @access private
	*/
	function _updateCellType(&$table, $new_type='') 
	{

		// dont change anything if the new type id blank
		$new_type = trim($new_type);
		if (empty($new_type)) return false;

		// get the contentType
		$link = $GLOBALS['SQ_SYSTEM']->am->getLinkById($this->attributes['linkid'], $table->id);
		if (empty($link)) return false;
		$content_type = &$GLOBALS['SQ_SYSTEM']->am->getAsset($link['minorid'], $link['minor_type_code']);

		// if the new type is the same as the current, change nothing
		$current_type = get_class($content_type);
		if ($current_type == $new_type) return false;

		// morph the content type to the new type
		// first up
		if (!$content_type->morph('content_type')) return false;
		// then down
		if (!$content_type->morph($new_type)) return false;

		$this->setAttribute('content_type', $new_type);

		return true;

	}//end _updateCellType()


	/**
	* Prints the JavaScript needed by the backend functions for this cell
	*
	* @param int	$cellid	the id of this cell
	*
	* @return boolean
	* @access public
	*/
	function printBackendJsData($cellid)
	{
		?>

									case <?php echo $cellid?> :
										retVal["attributes"] = '<?php echo var_serialise($this->attributes, true)?>';
									break;
		<?php

	}//end printBackendJsData()


}//end Class BodyCopy_Table_Cell

?>
