<?php
/**
* +--------------------------------------------------------------------+
* | This MySource Matrix CMS file is Copyright (c) Squiz Pty Ltd       |
* | ABN 77 084 670 600                                                 |
* +--------------------------------------------------------------------+
* | IMPORTANT: Your use of this Software is subject to the terms of    |
* | the Licence provided in the file licence.txt. If you cannot find   |
* | this file please contact Squiz (www.squiz.com.au) so we may provide|
* | you a copy.                                                        |
* +--------------------------------------------------------------------+
*
*/

require_once SQ_DATA_PATH.'/private/conf/tools.inc';
require_once SQ_CORE_PACKAGE_PATH.'/file_folders/file_folder/file_folder.inc';

/**
* Js_File_Folder
*
* @author  Chiranjivi Upreti <cupreti@squiz.com.au>
* @version $Revision: $
* @package MySource_Matrix_Packages
* @subpackage __core__
*/
class Js_File_Folder extends File_Folder
{


	/**
	* Constructor
	*
	* @param int	$assetid	the asset id to be loaded
	*
	*/
	function __construct($assetid=0)
	{
		parent::__construct($assetid);

	}//end constructor


	/**
	* Get the extension of the folder's file type
	*
	* @return boolean
	* @access public
	*/
	public function getFileExtension()
	{
		return 'js';

	}//end getFileExtension()


	/**
	* Get the file asset type that this folder supports
	*
	* @return boolean
	* @access public
	*/
	public function getFileAssetType()
	{
		return 'js_file';

	}//end getFileAssetType()


	/**
	* Prints out the frontend for this file with no design
	*
	* This function appends the "SourceMap" comment to the file's output to signify the Source Map files
	* Relevant when using Closure compiler with "Source Map" option
	*
	* @return void
	* @access public
	* @see File::printFrontend()
	*/
	public function printFrontend()
    {
		// if we are in limbo, we want to show our editing interface and design
		// instead of just sending our file over
		// there is an exception to it: In Limbo, if we have ?a=<assetid> at the end of the URL
		// and <assetid> value is different from the current asset assetid we are sending our file over
		if (SQ_IN_LIMBO && !(isset($_REQUEST['a']) && $_REQUEST['a'] == $this->id)) {
			return parent::printFrontend();
		}

		if (!$this->readAccess()) {
			$GLOBALS['SQ_SYSTEM']->paintLogin(translate('login'), translate('cannot_access_asset', $this->name));
			return;
		}

		parent::printFrontend();

		// If GET var "sm_file" is set then we are servering one of the "Source Map" files
		// See self::getExistingFile()
		if ($this->sourceMapEnabled() && !isset($_REQUEST['sm_file'])) {
			// Append the Source Map file URL comment
			echo "\r\n".'//# sourceMappingURL='.$this->getUrl().'?sm_file='.$this->attr('name').'.map';
		}

	}//end printFrontend()


	/**
	* Merge the linked file into a single file
	*
	* @return boolean
	* @access public
	*/
	public function mergeFiles()
	{
		$compiler_type = $this->attr('compiler_type');

		$success = TRUE;
		if ($compiler_type == 'closure' || $compiler_type == 'closure_with_sm') {

			$linked_file_assetids = $this->getLinkedFiles();
			if (empty($linked_file_assetids)) {
				return TRUE;
			}

			// Get the source file paths
			$source_files = Array();
			foreach($linked_file_assetids as $linked_file_assetid) {
				$linked_file = $GLOBALS['SQ_SYSTEM']->am->getAsset($linked_file_assetid);
				$file_info = $linked_file->getExistingFile();
				if (empty($file_info['path'])) {
					trigger_error('File path not found for the asset #'.$linked_file_assetid, E_USER_WARNING);
					continue;
				}
				$source_files[] = $file_info['path'];
			}//end foreach
			if (empty($source_files)) {
				return TRUE;
			}

			// Build the command for the Closure compiler
			$create_source_map = $compiler_type == 'closure_with_sm';
			$source_map_file = '';
			if ($create_source_map) {
				$source_map_file = $this->data_path.'/'.$this->attr('name').'.map';
			}

			// Temp output file
			$output_file = tempnam(SQ_TEMP_PATH, 'js_min_');

			$command = 'java -jar '.SQ_TOOL_CLOSURE_COMPILER_PATH.' '.
							'--js '.implode(' ', $source_files).' '.
							($create_source_map ? '--create_source_map '.$source_map_file.' ' : '').
							'--source_map_format=V3'.' '.
							'--js_output_file '.$output_file;

			if (!$this->_runCommand($command)) {
				trigger_error("Running Closure compiler command '".$command."' failed", E_USER_WARNING);
				return FALSE;
			}

			// Make sure we have got the output file
			if (!file_exists($output_file)) {
				trigger_error("Output file not generated by the Closure compiler", E_USER_WARNING);
				return FALSE;
			}
			// Get the compiled output
			$content = file_get_contents($output_file);
			unlink($output_file);

			// Handle the Source Map files
			if ($create_source_map) {
				if (!file_exists($source_map_file)) {
					trigger_error("Source Map file not generated by the Closure compiler", E_USER_WARNING);
					return FALSE;
				}
				
				// Save the additional Source Map filenames
				$source_map_files = Array();
				foreach(array_merge(Array($source_map_file), $source_files) as $file_path) {
					if (!empty($file_path)) {
						$filename = basename($file_path);
						$source_map_files[] = $filename;
					}
				}//end foreach
				$success = $this->setAttrValue('source_map_files', $source_map_files);

				// Add the source map files to the asset data dir(s)
				if ($success && !$this->_addSourceMapFiles(array_merge(Array($source_map_file), $source_files))) {
					return FALSE;
				}

				// Add the special comment to signify browser about the Source Map
				// This works for unrestricted public file only
				$content .= "\r\n".'//# sourceMappingURL='.basename($source_map_file);
			}

			// Update our file content
			if (!$this->setFileContent($content)) {
				return FALSE;
			}

		} else {
			$success = $this->setAttrValue('source_map_files', Array()) && parent::mergeFiles();
		}

		return $success;

	}//end mergeFiles()


	/**
	* Add additional Source Map files to the data dir(s)
	*
	* @param array $files
	* @param string $source_files
	*
	* @return boolean
	* @access private
	*/
	private function _addSourceMapFiles($files)
	{
		$success = TRUE;

		// Copy the source files to the asset data dir
		$fv = $GLOBALS['SQ_SYSTEM']->getFileVersioning();
		foreach($files as $index => $source_path) {
			$filename = basename($source_path);

			// If its "Source Map file", we need to fix its contents first
			if ($filename == $this->attr('name').'.map') {
				$this->_adjustSourceMapFileContent($source_path);
			}

			// Copy the files to the asset data dir
			if ($source_path != $this->data_path.'/'.$filename) {
				if (!copy($source_path, $this->data_path.'/'.$filename)) {
					trigger_localised_error('CORE0036', E_USER_WARNING, $source_path, $this->data_path.'/'.$filename);
					$success = FALSE;
					continue;
				}
			}

			// Add/Update the file
			$file_status = $fv->upToDate($this->data_path.'/'.$filename);
			if ($file_status & FUDGE_FV_NOT_CHECKED_OUT) {
				if (!$fv->add($this->data_path_suffix, $this->data_path.'/'.$filename)) {
					trigger_error("Cannot add Source Map file '".$filename."' to the repository", E_USER_WARNING);
					$success = FALSE;
					continue;
				}

				if (!$fv->checkOut($this->data_path_suffix.'/'.$filename, $this->data_path)) {
					trigger_localised_error('COR0103', E_USER_WARNING);
					$success = FALSE;
					continue;
				}

			} else if ($file_status & FUDGE_FV_MODIFIED) {
				if (!$fv->commit($this->data_path.'/'.$filename, '')) {
					trigger_localised_error('CORE0034', E_USER_WARNING);
					$success = FALSE;
					continue;
				}
			}

		}//end foreach

		if (!$success) {
			return FALSE;
		}

		$safe_files = Array('.', '..', $this->attr('name'), 'd.'.$this->attr('name').'.map');
		foreach($files as $file) {
			$safe_files[] = basename($file);
		}

		// Remove the old files in the data dir and well as from the repo
		$allowed_exts = Array('map', $this->getFileExtension());
		$dir_files = scandir($this->data_path);
		foreach($dir_files as $filename) {
			if (!in_array($filename, $safe_files) && in_array(pathinfo($filename, PATHINFO_EXTENSION), $allowed_exts)) {
				$result = $fv->remove($this->data_path.'/'.$filename);
				if ($result != FUDGE_FV_OK && $result != FUDGE_FV_NOT_CHECKED_OUT) {
					trigger_localised_error('CORE0042', E_USER_WARNING);
					continue;
				}
				// Remove public file
				$unrestricted = $this->data_path_public.'/'.$filename;
				if (is_file($unrestricted)) {
					$fv->clearOut($unrestricted);
				}
			}//end if
		}//end foreach

		// Update public dir
		if ($this->usePublicPath()) {
			$this->_updatePublicFile();
		}

		return $success;

	}//end _addSourceMapFiles()


    /**
    * Look's after the updating of files in the public directory.
    * Only call if File::usePublicPath() returns TRUE;
    *
    * @return boolean
    * @access private
	* @see File::_updatePublicFile()
    */
    protected function _updatePublicFile()
	{
		if (!parent::_updatePublicFile()) {
			return FALSE;
		}

		$success = TRUE;
		$fv = $GLOBALS['SQ_SYSTEM']->getFileVersioning();

		$sm_files = $this->attr('source_map_files');
		foreach($sm_files as $filename) {
			$unrestricted = $this->data_path_public.'/'.$filename;
			if (!file_exists($unrestricted) || $fv->upToDate($unrestricted) & (FUDGE_FV_NOT_CHECKED_OUT | FUDGE_FV_OLD_VERSION)) {
				if (file_exists($unrestricted)) {
					unlink($unrestricted);
				}

				if (!$fv->checkOut($this->data_path_suffix.'/'.$filename, $this->data_path_public)) {
					trigger_localised_error('CORE0032', E_USER_WARNING);
					$success = FALSE;
				}
			}//end if
		}//end foreach

		return $success;

	}//end _updatePublicFile()


	/**
	* Look's after the removing of files in the public directory
	*
	* @return boolean
	* @access private
	* @see File::_removePublicFile()
	*/
	protected function _removePublicFile()
	{
		if (!parent::_removePublicFile()) {
			return FALSE;
		}

		$success = TRUE;
		$fv = $GLOBALS['SQ_SYSTEM']->getFileVersioning();

		$sm_files = $this->attr('source_map_files');
		foreach($sm_files as $filename) {
			$unrestricted = $this->data_path_public.'/'.$filename;
			if (is_file($unrestricted)) {
				if (!($fv->clearOut($unrestricted) & FUDGE_FV_OK)) {
					trigger_localised_error('CORE0104', E_USER_WARNING);
					$success = FALSE;
				}
			}
		}

        return $success;

    }//end _removePublicFile()


	/**
	* Look's after the placing and removing of out files in the public directory
	*
	* @return boolean
	* @access protected
	* @see File::_checkFileState()
	*/
    protected function _checkFileState()
	{
		if (!parent::_checkFileState()) {
			return FALSE;
		}

		// Check the file status of the individual Source Map files as well
		$source_map_files = $this->_getSourceMapFiles();
		foreach($source_map_files as $file) {
			if (!parent::_checkFileState($file, FALSE)) {
				return FALSE;
			}
		}//end foreach

		$this->_generateDynamicSourceMapFile(TRUE);

		return TRUE;

	}//end _checkFileState()


	/**
	* Adjust Source Map file paths in the Source Map file
	*
	* @param string $source_map_file	File path of the Source Map file
	*
	* @return boolean
	* @access private
	*/
	private function _adjustSourceMapFileContent($source_map_file)
	{
		$public_dir = $this->attr('allow_unrestricted') && $this->effectiveUnrestricted();

		// Fix the source file paths in the Source Map file to make them relative
		$sm_array = json_decode_array(file_get_contents($source_map_file));
		if (!is_null($sm_array)) {
			$sm_array['file'] = $this->attr('name');
			foreach($sm_array['sources'] as &$sm_names_file) {
				$sm_names_file = basename($sm_names_file);
			}//end foreach
		} else {
			// Bad source map file
			return FALSE;
		}

		// Update the Souce Map file
		if (!file_put_contents($source_map_file, json_encode_array($sm_array))) {
			trigger_error("Cannot update the Source Map file to adjust the Matrix file paths", E_USER_WARNING);
			return FALSE;
		}

		return TRUE;

	}//end _adjustSourceMapFileContent()


	/**
	* Get an array of some useful data about the existing uploaded file
	* Overriden here to handle the asset's additional Souce Map files
	*
	* @return array
	* @access public
	* @see File::getExistingFile()
	*/
	public function getExistingFile()
	{
		// When Matrix is servring the Source Map file, the requested filename is passed in GET var
		$sm_filename = array_get_index($_REQUEST, 'sm_file', '');

		// Make sure the file being requested is legit
		$valid_files = $this->attr('source_map_files');
		if ($this->sourceMapEnabled() && $sm_filename && in_array($sm_filename, $valid_files)) {

			$file_path = $this->data_path.'/'.$sm_filename;
			if (is_file($file_path)) {
				if ($sm_filename == $this->attr('name').'.map') {
					// Source Map file when serverd by Matrix needs to be created dynamically
					$file_info = $this->_generateDynamicSourceMapFile();
				}  else {
					$file_info = Array(
								'path' => $file_path,
								'modified' => filemtime($file_path),
								'size' =>  filesize($file_path),
								'filename' => $sm_filename,
							);
				}

				return $file_info;
			}
		}

		return parent::getExistingFile();;

	}//end getExistingFile()


	/**
	* Get the Source Map file when the file is being served by Matrix
	*
	* This file is generated based on the regular "Source Map" file,
	* which is generated at the Closure compilation
	*
	* @param boolean $force_update
 	*
	* @return array
	* @access private
	*/
	private function _generateDynamicSourceMapFile($force_update=FALSE)
	{
		if (!$this->sourceMapEnabled()) {
			return Array();
		}

		$sm_filename = $this->attr('name').'.map';
		$sm_path = $this->data_path.'/'.$sm_filename;

		// Dynamic source map file
		$dsm_filename = 'd.'.$sm_filename;
		$dsm_path = $this->data_path.'/'.$dsm_filename;

		if ($force_update || !is_file($dsm_path) || filemtime($dsm_path) < filemtime($sm_path)) {
			$sm_array = json_decode_array(file_get_contents($sm_path));
			if (!is_null($sm_array)) {
				$url = $this->getUrl();
				$sm_array['file'] = $url;
				foreach($sm_array['sources'] as &$sm_names_file) {
					$sm_names_file = $url.'?sm_file='.$sm_names_file;
				}//end foreach
			} else {
				// Bad source map file
				return Array();
			}

			// Update the Souce Map file
			if (!file_put_contents($dsm_path, json_encode_array($sm_array))) {
				trigger_error("Cannot update the Dyanamic Source Map file to adjust the Matrix file paths", E_USER_WARNING);
				return Array();
			}

		}//end if update required

		$file_info = Array(
						'path' => $dsm_path,
						'modified' => filemtime($dsm_path),
						'size' =>  filesize($dsm_path),
						'filename' => $dsm_filename,
					);

		return $file_info;

	}//end _generateDynamicSourceMapFile()


    /**
    * Called to force an update of this assets lookup information
	*
	* Once the webpath changes, we need to make sure the dyanamic source map
	* file has the urls updated in its content
    *
    * @return boolean
    * @access public
    * @see File::updateLookups(), Asset::updateLookups(), Asset::saveWebPaths()
    */
    public function updateLookups($auto_add_remaps = TRUE)
	{
		if (!parent::updateLookups($auto_add_remaps)) {
			return FALSE;
		}

		$this->_generateDynamicSourceMapFile(TRUE);

		return TRUE;

	}//end updateLookups()


	/**
	* Saves a copy of this asset at this point in time
	* This copy gets used when the asset is live and the user does not have write access
	*
	* @return boolean
	* @access public
	* @see File::saveSystemVersion()
	*/
	public function saveSystemVersion()
	{
		if (!parent::saveSystemVersion()) {
			return FALSE;
		}

		// Store the current version of the Source Map files
		$fv = $GLOBALS['SQ_SYSTEM']->getFileVersioning();
		$source_map_files = $this->attr('source_map_files');

		$files_version_info = Array();
		foreach($source_map_files as $filename) {
			$file_info = $fv->_checkOutCheck($this->data_path_suffix.'/'.$filename);
			$latest_version = array_get_index($file_info, 'version', NULL);
			$files_version_info[$filename] = $latest_version;
		}//end foreach

		if (!string_to_file(serialize($files_version_info), $this->data_path.'/.sq_system/sq_system_version_no_additional_files')) {
			trigger_localised_error('CORE0051', E_USER_WARNING, $filename);
			return FALSE;
		}//end if


		return TRUE;

	}//end saveSystemVersion()


	/**
	* Replaces the editing version with the system (live) version
	* Handles the Source Map files
	*
	* @return boolean
	* @access public
	* @see File::revertToSystemVersion()
	*/
	public function revertToSystemVersion()
	{
		// Get the version info of the System version Source Map files before its get cleared
		$se_filenames = Array();
		if (file_exists($this->data_path.'/.sq_system/sq_system_version_no_additional_files')) {
			$se_filenames = @unserialize(file_get_contents($this->data_path.'/.sq_system/sq_system_version_no_additional_files'));
		}

		if (!parent::revertToSystemVersion()) {
			return FALSE;
		}

		// Get rid of the editing version Source Map files
		$this->_clearSourceMapFiles();

		$fv = $GLOBALS['SQ_SYSTEM']->getFileVersioning();
		foreach($se_filenames as $se_filename => $file_version) {
			$rep_path = $this->data_path_suffix.'/'.$se_filename;
			// Check out the old version of the file into the private data directory
			if (!$fv->checkOut($rep_path, $this->data_path, $file_version)) {
				trigger_localised_error('CORE0044', E_USER_WARNING, $se_filename);
				return FALSE;
			}

			// Create a new versioning entry for the old version
			$file_info = $fv->_checkOutCheck($rep_path, $file_version);
			$fv->_updateFile($file_info['fileid'], $this->data_path_suffix, $this->data_path.'/'.$se_filename);

			// Check out the new version
			if (!$fv->checkOut($rep_path, $this->data_path)) {
				trigger_localised_error('CORE0044', E_USER_WARNING, $this->name);
				return FALSE;
			}

		}//end foreach

		return TRUE;

	}//end revertToSystemVersion()


	/**
	* Remove the current Source Map files for the data dir
	*
	* @return boolean
	* @access private
	*/
	function _clearSourceMapFiles()
	{
		$fv = $GLOBALS['SQ_SYSTEM']->getFileVersioning();
		// Get rid of the editing version Source Map files
		$edit_version_files = $this->_getSourceMapFiles();
		foreach($edit_version_files as $ev_filename) {
			$result = $fv->remove($this->data_path_suffix.'/'.$ev_filename, '');
			if ($result != FUDGE_FV_OK && $result != FUDGE_FV_NOT_CHECKED_OUT) {
				trigger_localised_error('CORE0042', E_USER_WARNING);
				return FALSE;
			}
		}//end foreach

		return TRUE;

	}//end _clearSourceMapFiles


	/**
	* Returns TRUE if Source Map is enabled and we have a Souce Map file
	*
	* @return boolean
	* @access public
	*/
	public function sourceMapEnabled()
	{
		if ($this->attr('compiler_type') == 'closure_with_sm')  {
			return is_file($this->data_path.'/'.$this->attr('name').'.map');
		}

		return FALSE;

	}//end sourceMapEnabled()


	/**
	* Returns the current Source Map files in the asset's data dir
	*
	* @return array
	* @access private
	*/
	private function _getSourceMapFiles()
	{
		$source_map_files = Array();
		if (!is_dir($this->data_path)) {
			return $source_map_files;
		}

		$allowed_exts = Array('map', $this->getFileExtension());
		$dir_files = scandir($this->data_path);
		$safe_files = Array('.', '..');
		foreach($dir_files as $filename) {
			if ($filename == $this->attr('name') || $filename == 'd.'.$this->attr('name').'.map') {
				// This is asset's main file, or the dynamic source map file
				continue;
			}
			$file_path = $this->data_path.'/'.$filename;
			if (!in_array($filename, $safe_files) && is_file($file_path) && in_array(pathinfo($filename, PATHINFO_EXTENSION), $allowed_exts)) {
				$source_map_files[] = $filename;
			}
		}//end foreach

		return $source_map_files;

	}//end _getSourceMapFiles()


	/**
	* Run the Closure compiler command to merge the files
	*
	* @param string $command 	Closure command
	*
	* @return boolean
	* @access private
	*/
	private function _runCommand($command)
	{
		// Run the command
		$log = Array(
					'pipe',
					'w',
			   );

		$status = FALSE;
		$spec = Array(
					0	=> Array(
								'pipe',
								'r',
						   ),					// stdin is a pipe that the child will read from
					1	=> $log,				// stdout is a pipe that the child will write to
					2	=> $log,				// stderr is a file to write to
				);

		$cwd = NULL;
		$env = Array();
		$process = proc_open($command, $spec, $pipes, $cwd, $env);

		$status = 0;
		if (is_resource($process)) {
			fclose($pipes[0]);

			$content = stream_get_contents($pipes[1]);
			fclose($pipes[1]);

			$errors = stream_get_contents($pipes[2]);
			if (!empty($errors)) {
				$errors = array_unique(explode(PHP_EOL, $errors));
				trigger_error('Error occurred while running the Closure compiler: '.trim(implode(', ', $errors), ', '), E_USER_WARNING);
			}//end if
			fclose($pipes[2]);

			$status = proc_close($process);
		}

		return $status == 0;

	}//end _runCommand()


}//end class

?>
