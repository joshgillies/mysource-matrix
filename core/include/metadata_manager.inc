<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Open Source Licence                                      |
* +--------------------------------------------------------------------+
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +--------------------------------------------------------------------+
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +--------------------------------------------------------------------+
*
* $Id: metadata_manager.inc,v 1.83.2.2 2005/07/29 03:45:04 mmcintyre Exp $
*
*/

require_once SQ_FUDGE_PATH.'/general/text.inc';

/**
* Metadata_Manager
*
* Purpose
*    Manages the editing of metadata in the system
*
* @author  Greg Sherwood <greg@squiz.net>
* @version $Revision: 1.83.2.2 $
* @package MySource_Matrix
*/
class Metadata_Manager extends MySource_Object
{


	/**
	* Constructor
	*
	*/
	function Metadata_Manager()
	{
		$this->MySource_Object();

	}//end constructor


	/**
	* Check if all required fields have been completed for an asset
	*
	* If no values have been entered, the default schema values are checked
	*
	* @param string	$assetid	the ID of the asset to check
	*
	* @access public
	* @return boolean
	*/
	function requiredFieldsComplete($assetid)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) return true;

		$schemas = $this->getSchemas($asset->id, true);
		if (empty($schemas)) return true;

		$values = $this->getMetadata($asset->id);

		foreach ($schemas as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) continue;
			if (!is_a($schema, 'metadata_schema')) continue;
			$edit_fns = $schema->getEditFns();
			if (!$edit_fns->requiredFieldsComplete($schema, $values)) {
				return false;
			}
		}

		return true;

	}//end requiredFieldsComplete()


	/**
	* Check if all required fields have been completed for an asset
	*
	* @param string	$assetid	the ID of the asset to check
	*
	* @access public
	* @return boolean
	*/
	function allowsMetadata($assetid)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) return false;
		$edit_fns = $asset->getEditFns();
		return isset($edit_fns->static_screens['metadata']);

	}//end allowsMetadata()


//--        SCHEMAS        --//


	/**
	* Get an array of schemaIDs for all schemas applied and denied on an asset
	*
	* @param string		$assetid	the ID of the asset to get schemas for
	* @param boolean	$granted	type of access : null = all, true = applied, false = denied
	*
	* @access public
	* @return array	if $granted is null returns Array(schemaid)
	*				otherwise returns Array(schemaid => granted[1|0])
	*/
	function getSchemas($assetid, $granted=null)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$sql = '  SELECT DISTINCT schemaid, granted
				  FROM '.SQ_TABLE_RUNNING_PREFIX.'ast_mdata ';
		$where = 'assetid = '.$db->quote($assetid);
		if (!is_null($granted)) {
			$where .= ' AND granted = '.$db->quote((($granted) ? '1' : '0'));
		}
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

		$result = $db->getAll($sql.$where);
		assert_valid_db_result($result);

		$schemas = Array();
		foreach ($result as $data) {
			if (is_null($granted)) {
				$schemas[$data['schemaid']] = $data['granted'];
			} else {
				$schemas[] = $data['schemaid'];
			}
		}

		return $schemas;

	}//end getSchemas()


	/**
	* Apply a schema to or Deny from, an asset
	*
	* @param string		$assetid	the ID of the asset to set the schema on
	* @param string		$schemaid	the ID of the schema to set
	* @param boolean	$granted	is this schema applied (TRUE) or denied (FALSE)?
	*
	* @access public
	* @return boolean
	*/
	function setSchema($assetid, $schemaid, $granted)
	{
		$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_localised_error("SYS0047", E_USER_WARNING, $schemaid);
			return false;
		}

		if (!is_a($schema, 'metadata_schema')) {
			trigger_localised_error("SYS0045", E_USER_WARNING, $schema->name, $schemaid);
			return false;
		}

		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error("SYS0046", E_USER_WARNING, $assetid);
			return false;
		}

		if (!$asset->adminAccess('metadata')) {
			trigger_localised_error("SYS0031", E_USER_WARNING, $asset->name);
			return false;
		}

		// get the current schemas that are set
		$schemas = $this->getSchemas($assetid);

		// check if this schema is already set
		if (isset($schemas[$schemaid])) {
			if ((bool)$schemas[$schemaid] == $granted) {
				// schema is set with same access level
				return true;
			} else {
				// schema is set but with the opposite access level
				$new_access     = ($granted) ? 'apply'  : 'deny';
				$current_access = ($granted) ? 'denied' : 'applied';

				trigger_localised_error("SYS0032", E_USER_WARNING, $new_access, $schema->name, $asset->name, $current_access);
				return false;
			}
		}

		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'INSERT INTO
					sq_ast_mdata
					(
						assetid,
						schemaid,
						granted
					)
					VALUES
					(
						'.$db->quoteSmart($asset->id).',
						'.$db->quoteSmart($schemaid).',
						'.$db->quoteSmart((($granted) ? '1' : '0')).'
					)';

		$result = $db->query($sql);
		assert_valid_db_result($result);

		// add defaults to the indexing service
		if ($granted) {
			$em =& $GLOBALS['SQ_SYSTEM']->getEventManager();
			$em->broadcastEvent($asset, 'indexMetadata', Array('assetid' => $asset->id, 'schemaids' => Array($schemaid)));
			$this->generateContentFile($assetid, false);
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		return true;

	}//end setSchema()


	/**
	* Remove a set schema from an asset
	*
	* @param string	$assetid	the ID of the asset to delete the schema from
	* @param string	$schemaid	the ID of the schema to delete
	*
	* @access public
	* @return boolean
	*/
	function deleteSchema($assetid, $schemaid)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error("SYS0036", E_USER_WARNING, $assetid);
			return false;
		}

		if (!$asset->adminAccess('metadata')) {
			trigger_localised_error("SYS0029", E_USER_WARNING, $asset->name);
			return false;
		}

		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'DELETE FROM
					sq_ast_mdata
				WHERE
						schemaid	= '.$db->quoteSmart($schemaid).'
					AND	assetid		= '.$db->quoteSmart($asset->id);

		$result = $db->query($sql);
		assert_valid_db_result($result);

		$em =& $GLOBALS['SQ_SYSTEM']->getEventManager();
		$em->broadcastEvent($asset, 'indexMetadata', Array('assetid' => $asset->id, 'schemaids' => Array($schemaid)));
		$this->generateContentFile($assetid, false);

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		return true;

	}//end deleteSchema()


	/**
	* Get an array of assetIDs that have the passed schemaID applied or denied on them
	*
	* @param string		$schemaid	the ID of the schema to get assets for
	* @param boolean	$granted	type of access : null = all, true = applied, false = denied
	*
	* @access public
	* @return array( schemaid => granted[1|0] )
	*/
	function getSchemaAssets($schemaid, $granted=null)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$sql = 'SELECT DISTINCT
					assetid, granted
				FROM
					'.SQ_TABLE_RUNNING_PREFIX.'ast_mdata ';

		$where = 'schemaid = '.$db->quote($schemaid);
		if (!is_null($granted)) {
			$where .= ' AND granted = '.$db->quote((($granted) ? '1' : '0'));
		}
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

		$result = $db->getAll($sql.$where);
		assert_valid_db_result($result);

		$assets = Array();
		foreach ($result as $data) {
			if (is_null($granted)) {
				$assets[$data['assetid']] = $data['granted'];
			} else {
				$assets[] = $data['assetid'];
			}
		}

		return $assets;

	}//end getSchemaAssets()


	/**
	* Get an array of metatata fields IDs for a metadata schema
	*
	* @param string|array $schemaids	single schemaid or an array of schema ids whose fields we are getting
	*
	* @return array	Array(assetid => type_code)
	* @access public
	* @see Asset_Manager::getChildren()
	*/
	function getMetadataFields($schemaids)
	{
		if (!is_array($schemaids)) {
			return $GLOBALS['SQ_SYSTEM']->am->getChildren($schemaid, 'metadata_field', false);
		} else {
			$fieldids = Array();
			foreach ($schemaids as $schemaid) {
				$field_children = $GLOBALS['SQ_SYSTEM']->am->getChildren($schemaid, 'metadata_field', false);
				foreach ($field_children as $fieldid => $field_type) {
					$fieldids[$fieldid] = $field_type;
				}
			}
			return $fieldids;
		}

	}//end getMetadataFields()


//--        METADATA VALUES        --//


	/**
	* Get the metadata values set for an asset on a particular schema
	*
	* The array returned may have some fields missing. If there is no field value it
	* means that the field is using the default value (whatever that happens to be
	* at the time). This cuts down on storage and allows defaults to change over time
	* without updating metadata values.
	*
	* @param string		$assetid		the ID of the asset to get metadata for
	* @param string		$schemaid		optional ID of the schema to only the get metadata for
	*
	* @access public
	* @return array
	*/
	function getMetadata($assetid, $schemaid=0)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error("SYS0043", E_USER_WARNING, $assetid);
			return false;
		}

		// check that the schema we are getting metadata for is actually set
		$schemas = $this->getSchemas($assetid, true);
		if ($schemaid) {
			if (!in_array($schemaid, $schemas)) return Array();
			// restrict to just the one schema
			$schemas = Array($schemaid);
		}

		if (empty($schemas)) return Array();

		$db = &$GLOBALS['SQ_SYSTEM']->db;

		// And to think I didn't like it when this generating query got pulled out of the Asset_Manager::getChildren() :)
		// Instead of doing any thinking...let them do it all for us and use it in our query
		$sql = 'SELECT
					mv.fieldid, a.name, mv.value
				FROM
					'.SQ_TABLE_RUNNING_PREFIX.'ast_mdata_val mv
				INNER JOIN
					'.SQ_TABLE_RUNNING_PREFIX.'ast a ON mv.fieldid = a.assetid';

		$where = '	mv.assetid = '.$db->quoteSmart($asset->id).'
				AND (';

		foreach ($schemas as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) {
				trigger_localised_error("SYS0044", E_USER_WARNING, $schemaid);
				return false;
			}
			$where .= '
						mv.fieldid IN (
						'.implode(' ', $GLOBALS['SQ_SYSTEM']->am->generateGetChildrenQuery($schema, 'metadata_field', false, null, null, false)).'
						) OR ';

		}// end foreach

		$where = trim($where, ' OR ').'
					)';

		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'mv');
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'a');

		$metadata = $db->getAssoc($sql.$where);
		assert_valid_db_result($metadata);

		return $metadata;

	}//end getMetadata()


	/**
	* Get the default metadata values for a particular schema
	*
	* @param string	$schemaid	the ID of the schema to get default metadata for
	*
	* @access public
	* @return array
	*/
	function getSchemaDefaultValues($schemaid)
	{
		static $cached_field_names = Array();

		$am = &$GLOBALS['SQ_SYSTEM']->am;

		$schema = &$am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_localised_error("SYS0040", E_USER_WARNING, $schemaid);
			return Array();
		}

		$fields = $this->getMetadataFields(Array($schemaid));

		$default_values = Array();
		$field_names = Array();
		$fields_to_check = Array();

		foreach($fields as $fieldid => $type_code) {
			if (isset($cached_field_names[$fieldid])) {
				$field_names[$fieldid] = $cached_field_names[$fieldid];
			} else {
				$fields_to_check[] = $fieldid;
			}
		}
		$new_field_names = $GLOBALS['SQ_SYSTEM']->am->getAssetInfo($fields_to_check, 'metadata_field', false, 'name');
		$field_names += $new_field_names;

		foreach ($fields as $fieldid => $type_code) {
			if (!isset($cached_field_names[$fieldid])) {
				$cached_field_names[$fieldid] = $field_names[$fieldid];
			}

			$default_values[$fieldid] = Array(
											'name'	=> $field_names[$fieldid],
											'value'	=> $this->getMetadataFieldDefaultValue($fieldid),
										  );
		}

		return $default_values;

	}//end getSchemaDefaultValues()


	/**
	* Generate an array of current values for the passed metadata field names
	*
	* If the passed fields array is empty, all field values will be returned
	*
	* @param string			$assetid		the ID of the asset to get field values for
	* @param array(string)	$field_names	an array of field names
	*
	* @access public
	* @return array	Array(field_name => value)
	*/
	function getMetadataFieldValues($assetid, $field_names=Array())
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$am = &$GLOBALS['SQ_SYSTEM']->am;

		$db->show_queries = true;

		// the array of field values we are going to return
		$field_values = Array();

		$asset = &$am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error("SYS0038", E_USER_WARNING, $assetid);
			return $field_values;
		}

		$schemas = $this->getSchemas($asset->id, true);
		if (empty($schemas)) return $field_values;

		// get the values without any replacements or special processing
		$values = $this->getMetadata($asset->id);

		foreach ($schemas as $schemaid) {
			$schema = &$am->getAsset($schemaid);
			if (is_null($schema)) {
				trigger_localised_error("SYS0039", E_USER_WARNING, $schemaid);
				return $field_values;
			}

			if (!is_a($schema, 'metadata_schema')) {
				trigger_localised_error("SYS0037", E_USER_WARNING, $schema->name, $schemaid);
				return $field_values;
			}

			// Get all the fields that are in this schema (optionally restricted to the passed named fields)
			$sql_parts = $am->generateGetChildrenQuery($schema, 'metadata_field', false);
			// if they only want specific fields, then restrict the search to those
			if (!empty($field_names)) {
				$sql_parts['where'] .= ' AND a.name IN ('.$db->quote($field_names[0]);
				for ($i = 1; $i < count($field_names); $i++) {
					$sql_parts['where'] .= ', '.$db->quote($field_names[$i]);
				}
				$sql_parts['where'] .= ')';
			}

			$fields = $db->getAssoc(implode(' ', $sql_parts));
			assert_valid_db_result($fields);

			foreach ($fields as $fieldid => $type_code) {
				$sql = 'SELECT
							COALESCE()
						';
				$field = &$am->getAsset($fieldid, $type_code);
				if (is_null($field)) {
					trigger_localised_error("SYS0041", E_USER_WARNING, $schemaid);
					continue;
				}

				$field_values[$field->name] = $field->getMetadataValue($asset, (isset($values[$field->id]) ? $values[$field->id]['value'] : null));

			}// end for

		}// end schema

		return $field_values;

	}//end getMetadataFieldValues()


	/**
	* Set metadata values for an asset
	*
	* @param string	$assetid	the ID of the asset to set the values for
	* @param array	$metadata	the values to set
	*
	* @access public
	* @return boolean
	*/
	function setMetadata($assetid, $metadata)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error("SYS0043", E_USER_WARNING. $assetid);
			return false;
		}

		if (!$asset->writeAccess('metadata')) {
			trigger_localised_error("SYS0030", E_USER_WARNING, $asset->name);
			return false;
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		// find all the fields...for two reasons.
		// 1. make sure they are editable
		// 2. we need to do some cleanup incase there has been a change in the fields that are available for this asset
		$quoted_fieldids = Array();
		foreach (array_keys($metadata) as $fieldid) {

			$field = &$GLOBALS['SQ_SYSTEM']->am->getAsset($fieldid);
			if (is_null($field) || !$field->attr('editable')) {
				unset($metadata[$fieldid]);
				continue;
			}
			$quoted_fieldids[] = $db->quoteSmart($fieldid);

		}//end foreach

		// Remove any old values...it's just easier than having to screw about with old fields and new fields, different assetids for the same name etc
		$where = '	assetid = '.$db->quoteSmart($asset->id);
		if (!empty($quoted_fieldids)) {
			$where .= ' AND fieldid NOT IN ('.implode(',', $quoted_fieldids).')';
		}

		$sql = 'DELETE FROM
					sq_ast_mdata_val
				WHERE
					'.$where;

		$result = $db->query($sql);
		assert_valid_db_result($result);

		if (!empty($quoted_fieldids)) {
			// Find any fields that have existing entries...so we know what to update and what to insert
			$sql = 'SELECT
						fieldid
					FROM
						'.SQ_TABLE_RUNNING_PREFIX.'ast_mdata_val';

			$where = '	assetid = '.$db->quote($asset->id).'
					 AND fieldid IN ('.implode(',', $quoted_fieldids).')';

			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);
			$updates = $db->getCol($sql.$where);
			assert_valid_db_result($updates);

			$sql = 'INSERT INTO
						sq_ast_mdata_val
						(
							assetid,
							fieldid,
							value
						)
						VALUES
						(
							?,
							?,
							?
						)';

			$insert_prepared = $db->prepare($sql);
			assert_valid_db_result($insert_prepared);

			$sql = 'UPDATE
						sq_ast_mdata_val
					SET
						value	= ?
					WHERE
							assetid	= ?
						AND	fieldid	= ?';

			$update_prepared = $db->prepare($sql);
			assert_valid_db_result($update_prepared);

			for (reset($metadata); NULL !== ($fieldid = key($metadata)); next($metadata)) {

				// we need to insert
				if (!in_array($fieldid, $updates)) {

					$values = Array(
								$asset->id,
								$fieldid,
								$metadata[$fieldid]['value'],
							  );

					$result = $db->execute($insert_prepared, $values);
					assert_valid_db_result($result);

				// we are updating
				} else {
					$values = Array(
								$metadata[$fieldid]['value'],
								$asset->id,
								$fieldid,
							  );

					$result = $db->execute($update_prepared, $values);
					assert_valid_db_result($result);

				}//end if

			}//end for

			$db->freePrepared($insert_prepared);
			$db->freePrepared($update_prepared);

		}// end if

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');

		$em =& $GLOBALS['SQ_SYSTEM']->getEventManager();
		$em->broadcastEvent($asset, 'indexMetadata', Array('assetid' => $assetid));

		return true;

	}//end setMetadata()


//--        (RE)GENERATE METADATA        --//


	/**
	* Generate a PHP file that can be included to print all metadata fields for an asset
	*
	* The generated file contains PHP code to do any keyword replacing based on
	* current values instead of the ones at the time of caching.
	*
	* @param string		$assetid		the ID of the asset to generate the file for
	* @param booelan	$regenerate		regenerate the DB information as well
	*
	* @access public
	* @return boolean
	*/
	function generateContentFile($assetid, $regenerate=false)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error("SYS0034", E_USER_WARNING, $assetid);
			return false;
		}

		$schemas = $this->getSchemas($asset->id, true);
		if (empty($schemas)) return false;

		// an array of all metadata tag values
		$tag_values = Array();

		// an array of keyword replacements that we are going to have to write some PHP code to produce
		$keywords = Array();

		// get the values without any replacements or special processing
		// Also used if we are regenerating
		$metadata = $this->getMetadata($asset->id);

		ob_start();
		foreach ($schemas as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) {
				trigger_localised_error("SYS0035", E_USER_WARNING, $schemaid);
				return false;
			}

			if (!is_a($schema, 'metadata_schema')) {
				trigger_localised_error("SYS0033", E_USER_WARNING, $schema->name, $schemaid);
				return false;
			}

			$edit_fns = $schema->getEditFns();
			$edit_fns->generateMetadata($schema, $metadata, $tag_values, $keywords);

			$GLOBALS['SQ_SYSTEM']->am->forgetAsset($schema);
		}

		$metadata_str = ob_get_contents();
		ob_end_clean();

		ob_start();
			echo '<'.'?php'."\n";
			if (!empty($keywords)) {
				require_once SQ_FUDGE_PATH.'/general/text.inc';
				echo '$metadata_asset = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset('.$asset->id.');'."\n\n";
				echo '/* 1 */', "\n";
				$replacements = $this->generateKeywordReplacements($asset, $keywords);
				echo '/* 2 */', "\n";
				$tag_values = replace_keywords($tag_values, $replacements);
				echo '/* 3 */', "\n";
				echo "\n\n";
			}

			$nested_tag_values = Array();
			$tag_nested_index = Array();
			foreach ($tag_values as $n => $v) {
				$matches = Array();
				$nested_index = 0;
				preg_match_all('|\$metadata_values\[\'([^\]]+)\'\]|', $v, $matches);
				if (!empty($matches[1])) {
					foreach ($matches[1] as $field_name) {
						// we have a nested field name
						for ($i = 0; $i < count($nested_tag_values); $i++) {
							if (isset($nested_tag_values[$i][$field_name])) {
								$v = preg_replace('|(\$metadata_values)(\[\')('.$field_name.')(\'\])|', '$metadata_values_'.$i.'[\'\\3\']', $v);
								if ($i >= $nested_index) $nested_index = $i + 1;
								break;
							}
						}
					}
				}

				$nested_tag_values[$nested_index][$n] = $v;
				$tag_nested_index[$n] = $nested_index;
			}

			foreach ($nested_tag_values as $i => $values) {
				echo '$metadata_values_'.$i.' = Array(';
				foreach ($values as $n => $v) {
					$v = stripslashes($v);
					$v = preg_replace('%\'%', '\\\'', $v);
					$v = preg_replace('%\"%', '&quot;', $v);
					$v = preg_replace('|(\$metadata_replacements\[)\\\\\'([^\]]+)\\\\\'(\])|', '\'.\\1\'\\2\'\\3.\'', $v);
					$v = preg_replace('|(\$metadata_values[^\[]+\[)\\\\\'([^\]]+)\\\\\'(\])|', '\'.\\1\'\\2\'\\3.\'', $v);
					echo "'$n' => '$v',\n";
				}
				echo ");\n";
			}

			echo '?'.'>';
			$php_str = ob_get_contents();
		ob_end_clean();

		$metadata_matches = Array();
		preg_match_all('|\$metadata_values\[\'([^\]]+)\'\]|', $metadata_str, $metadata_matches);
		foreach ($metadata_matches[1] as $field_name) {
			$metadata_str = preg_replace('|\$metadata_values\[\''.$field_name.'\'\]|', '$metadata_values_'.$tag_nested_index[$field_name].'[\''.$field_name.'\']', $metadata_str);
		}

		$metadata_str = $php_str."\n\n".$metadata_str;

		require_once SQ_FUDGE_PATH.'/general/file_system.inc';
		if (!create_directory($asset->data_path)) return false;
		if (!string_to_file($metadata_str, $asset->data_path.'/metadata.php')) {
			return false;
		}

		if (!$regenerate) {
			return true;
		} else {
			return $this->setMetadata($assetid, $metadata);
		}

	}//end generateContentFile()


	/**
	* Generate an array of keyword replacements, or the PHP code to generate it
	*
	* This function outputs the PHP required to generate all the keywords that
	* it is passed. All PHP generated places values in an array called $metadata_replacements
	* (which happens in the outputted PHP code). An array of replacements is returned that
	* can be used to replace all the keywords with a PHP string to output the correct value
	* from the $metadata_replacements array.
	*
	* This function can also return the values of the replacement values instead of the PHP code.
	*
	* @param object Asset	&$asset		the asset to use for replacment values
	* @param array			$keywords	an array of keywords in
	* @param boolean		$generating	generate the PHP code or not (which generates the value)
	*
	* @access public
	* @return array(keyword => replacement)
	*/
	function generateKeywordReplacements(&$metadata_asset, $keywords, $generating=true)
	{
		$metadata_replacements = Array();
		$keywords = array_unique($keywords);

		if (!empty($keywords) && $generating) {
			echo '$metadata_replacements = Array();'."\n";
		}

		$thumbnail_generated = false;

		foreach ($keywords as $keyword) {

			if ($generating) {
				$metadata_replacements[$keyword] = '$metadata_replacements['.var_export($keyword, 1).']';
			} else {
				ob_start();
			}

			switch ($keyword) {

				case 'asset_name'       :
				case 'asset_short_name' :
				case 'asset_version'    :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_asset->'.substr($keyword,6).';'."\n";
				break;

				case 'asset_url' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_asset->getURL();'."\n";
				break;

				case 'asset_href' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_asset->getHref();'."\n";
				break;

				case 'asset_thumbnail' :
				case 'asset_thumbnail_url' :
				case 'asset_thumbnail_caption' :
					if (!$thumbnail_generated) {
						echo '$thumbnail = null;';
						echo 'if ($metadata_asset->id) {';
						echo '    $link = $GLOBALS[\'SQ_SYSTEM\']->am->getLink($metadata_asset->id, SQ_LINK_NOTICE, \'thumbnail\', true, \'thumbnail\');'."\n";
						echo '    if (!empty($link)) {'."\n";
						echo '        $thumbnail = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($link[\'minorid\'], $link[\'minor_type_code\']);'."\n";
						echo '    }'."\n";
						echo '}'."\n";
					}
					switch ($keyword) {
						case 'asset_thumbnail' :
							echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($thumbnail)) ? \'\' : $thumbnail->printImageTag(\'\', \'\', true);'."\n";
							break;
						case 'asset_thumbnail_url' :
							echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($thumbnail)) ? \'\' : $thumbnail->getURL();'."\n";
							break;
						case 'asset_thumbnail_caption' :
							echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($thumbnail)) ? \'\' : $thumbnail->attr(\'caption\');'."\n";
							break;
					}

				break;

				case 'asset_created' :
				case 'asset_updated' :
				case 'asset_status_changed':
					echo '$metadata_replacements['.var_export($keyword, 1).'] = date(\'Y-m-d H:i:s\', $metadata_asset->'.substr($keyword,6).');'."\n";
				break;

				case 'asset_created_short' :
				case 'asset_updated_short' :
				case 'asset_status_changed_short':
					echo '$metadata_replacements['.var_export($keyword, 1).'] = date(\'Y-m-d\', $metadata_asset->'.substr($keyword, strlen('asset_'), strlen($keyword) - strlen('_short') - strlen('asset_')).');'."\n";
				break;

				case 'asset_created_readable' :
				case 'asset_updated_readable' :
				case 'asset_status_changed_readable':
					echo '$metadata_replacements['.var_export($keyword, 1).'] = date(\'d M Y g:ia\', $metadata_asset->'.substr($keyword, strlen('asset_'), strlen($keyword) - strlen('_readable') - strlen('asset_')).');'."\n";
				break;

				case 'asset_created_iso8601' :
				case 'asset_updated_iso8601' :
				case 'asset_status_changed_iso8601' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = date(\'Y-m-d\\TH:i:s\', $metadata_asset->'.substr($keyword, strlen('asset_'), strlen($keyword) - strlen('_iso8601') - strlen('asset_')).');'."\n";
				break;

				case 'asset_created_rfc2822' :
				case 'asset_updated_rfc2822' :
				case 'asset_status_changed_rfc2822' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = date(\'r\', $metadata_asset->'.substr($keyword, strlen('asset_'), strlen($keyword) - strlen('_rfc2822') - strlen('asset_')).');'."\n";
				break;

				case 'asset_created_ical' :
				case 'asset_updated_ical' :
				case 'asset_status_changed_ical' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = date(\'Ymd\\THis\', $metadata_asset->'.substr($keyword, strlen('asset_'), strlen($keyword) - strlen('_ical') - strlen('asset_')).');'."\n";
				break;


				case 'asset_created_by_name' :
				case 'asset_updated_by_name' :
				case 'asset_status_changed_by_name':
					$field_name = substr($keyword, strlen('asset_'), strlen($keyword) - strlen('_by_name') - strlen('asset_'));
					echo 'if (!isset($metadata_'.$field_name.'_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->'.$field_name.'_userid));
					if (!empty($asset_info)) {
					$metadata_'.$field_name.'_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->'.$field_name.'_userid);'."\n}\n}\n";
					echo 'if (!empty($metadata_'.$field_name.'_by_user)) { ';
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_'.$field_name.'_by_user->name;'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = \'System\';'."\n";
					echo '}'."\n";
				break;

				case 'asset_created_by_first_name' :
				case 'asset_created_by_last_name'  :
				case 'asset_created_by_email'      :
				case 'asset_updated_by_first_name' :
				case 'asset_updated_by_last_name'  :
				case 'asset_updated_by_email'      :
					echo 'if (!isset($metadata_'.substr($keyword,6,7).'_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->'.substr($keyword,6,7).'_userid));
					if (!empty($asset_info)) {
					$metadata_'.substr($keyword,6,7).'_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->'.substr($keyword,6,7).'_userid,\'\', true);'."\n}\n}\n";
					echo 'if (!empty($metadata_'.substr($keyword,6,7).'_by_user)) { ';
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_'.substr($keyword,6,7).'_by_user->attr(\''.substr($keyword,17).'\');'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = \'\';'."\n";
					echo '}'."\n";

				break;

				// can't handle 'last published' stuff in the same way as created/updated because
				// there is a chance that it has never been published
				case 'asset_published' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'Y-m-d H:i:s\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_short' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'Y-m-d\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_readable' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'d M Y g:ia\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_iso8601' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'Y-m-d\\TH:i:s\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_ical' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'Ymd\\THis\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_rfc2822' :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'r\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_by_name' :
					echo 'if (is_null($metadata_asset->published_userid)) {'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = \'Never Published\';'."\n";
					echo '} else { if (!isset($metadata_published_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->published_userid));
					if (!empty($asset_info)) {
					$metadata_published_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->published_userid);'."\n}\n}\n";
					echo 'if (!empty($metadata_published_by_user)) { ';
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_published_by_user->name;'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = \'System\';'."\n";
					echo '}}'."\n";
				break;

				case 'asset_published_by_first_name' :
				case 'asset_published_by_last_name'  :
				case 'asset_published_by_email'      :
					echo 'if (is_null($metadata_asset->published_userid)) {'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = \'\';'."\n";
					echo '} else { if (!isset($metadata_published_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->published_userid));
					if (!empty($asset_info)) {
					$metadata_published_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->published_userid);'."\n}\n}\n";
					echo 'if (!empty($metadata_published_by_user)) { ';
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_published_by_user->attr(\''.substr($keyword,19).'\');'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = \'\';'."\n";
					echo '}}'."\n";

				break;

				case 'asset_read_permission'  :
				case 'asset_write_permission' :
				case 'asset_admin_permission' :
					$perm_type = str_replace('_permission', '', $keyword);
					$perm_type = substr($perm_type,6);
					echo '$metadata_'.$perm_type.'_perms = $GLOBALS[\'SQ_SYSTEM\']->am->getPermission($metadata_asset->id, SQ_PERMISSION_'.strtoupper($perm_type).', true, false, true);'."\n";
					echo '$metadata_'.$perm_type.'_perm_names = \'\';'."\n";
					echo 'foreach ($metadata_'.$perm_type.'_perms as $userid) {'."\n";
					echo '	$user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($userid);'."\n";
					echo '	if (is_null($user)) continue;'."\n";
					echo '	$metadata_'.$perm_type.'_perm_names .= $user->name.\', \';'."\n";
					echo '}'."\n";
					echo '$metadata_'.$perm_type.'_perm_names = trim($metadata_'.$perm_type.'_perm_names, \', \');'."\n";
					echo '$metadata_replacements['.var_export($keyword, 1).'] = $metadata_'.$perm_type.'_perm_names;'."\n";
				break;

				case 'system_name'   :
				case 'system_owner'  :
				case 'default_email' :
				case 'tech_email'    :
					echo '$metadata_replacements['.var_export($keyword, 1).'] = SQ_CONF_'.strtoupper($keyword).';'."\n";
				break;

				default :

					// searching for keywords that replace the content of another field
					if (substr($keyword, 0, 15) == 'metadata_field_') {

						$field_name = substr($keyword, 15);
						$metadata_replacements[$keyword] = '$metadata_values[\''.$field_name.'\']';

					} else {

						// searching for special date format keywords
						$original = $keyword;
						$keyword = substr($keyword, 6);
						$key     = substr($keyword, 0, strpos($keyword, '_'));
						$extras  = substr($keyword, strpos($keyword, '_') +1);

						if (strpos($extras, '_') === false) {
							$format = $extras;
							$offset = '';
						} else {
							list ($format, $offset) = explode('_', $extras);
						}
						$format = str_replace('~', ' ', $format);

						switch ($key) {
							case 'created':
							case 'updated':
							case 'published':
								if (empty($offset)) {
									$date = '$metadata_asset->'.$key;
								} else {
									$date = 'strtotime(\''.$offset.'\', $metadata_asset->'.$key.')';
								}
								echo '$metadata_replacements[\''.$original.'\'] = date(\''.$format.'\', '.$date.');'."\n";
							break;
							default:
								echo '$metadata_replacements[\''.$original.'\'] = \'\';'."\n";
							break;
						}

					}//end if

				break;

			}//end switch


			if (!$generating) {
				eval(ob_get_contents());
				ob_end_clean();
			}
		}

		return $metadata_replacements;

	}//end generateKeywordReplacements()


	/**
	* Regenerate both the cached tag metadata and the serialised DB values
	*
	* @param string	$assetid	the ID of the asset to regenerate metadata for
	*
	* @access public
	* @return boolean
	*/
	function regenerateMetadata($assetid)
	{
		return $this->generateContentFile($assetid, true);

	}//end regenerateMetadata()


	/**
	* Removes the metadata entries for the specified asset
	*
	* @param string	$assetid	the assetid of the asset to purge
	*
	* @return boolean
	* @access public
	*/
	function purgeMetadata($assetid)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$where_cond = 'assetid = '.$db->quote($assetid);
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'DELETE FROM
					sq_ast_mdata
				WHERE
					assetid	= '.$db->quoteSmart($assetid);

		$result = $db->query($sql);
		assert_valid_db_result($result);

		$sql = 'DELETE FROM
					sq_ast_mdata_val
				WHERE
					assetid	= '.$db->quoteSmart($assetid);

		$result = $db->query($sql);
		assert_valid_db_result($result);

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');

		return true;

	}//end purgeMetadata()


	/**
	* Get the value of an asset's metadata field based on that field's asset ID
	*
	* @param string		$assetid		The ID of the asset that we want the
	*									metadata value of
	* @param string		$field_assetid	The field that we wish to check
	* @param boolean	$mute_errors	Set true to mute errors that occur when
	*									the asset (specified in $assetid) does
	*									not have a schema applied to it
	*/
	function getMetadataValueByAssetid($assetid, $field_assetid, $mute_errors=false)
	{
		// is this actually a metadata field or what?!
		if (!$this->isMetadataFieldAssetid($field_assetid)) {
			if (!$mute_errors) {
				trigger_localised_error('SYS0308', E_USER_WARNING, $field_assetid);
			}
			return null;
		}

		// get the parent schema of this metadata field
		$schemaid = $GLOBALS['SQ_SYSTEM']->am->getParents($field_assetid, 'metadata_schema');

		// get the schemas that apply to this asset
		$schemas = $this->getSchemas($assetid, true);

		if (array_intersect($schemas, array_keys($schemaid)) == Array()) {
			if (!$mute_errors) {
				// SYS0307: Asset #<assetid> does not have the schema for field #<field assetid> applied
				trigger_localised_error('SYS0307', E_USER_WARNING, $assetid, $field_assetid);
			}
			return null;
		}

		$db =& $GLOBALS['SQ_SYSTEM']->db;

		$sql = 'SELECT
					value
				FROM
					'.SQ_TABLE_RUNNING_PREFIX.'ast_mdata_val mdv';
		$where = 'mdv.assetid	= '.$db->quoteSmart($assetid).'
					AND	mdv.fieldid	= '.$db->quoteSmart($field_assetid);
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'mdv');

		$value = $db->getOne($sql.$where);

		if (is_null($value)) {
			// not set - need the default value
			return $this->getMetadataFieldDefaultValue($field_assetid);
		} else {
			return $value;
		}

	}//end getMetadataValueByAssetid()


	/**
	* Returns whether the asset ID being passed into this function is some kind
	* of metadata field asset
	*
	* @param string	$field_assetid	the ID of the metadata field asset
	*
	* @return boolean
	* @access public
	*/
	function isMetadataFieldAssetid($field_assetid)
	{
		static $cached_tests = Array();

		if (!isset($cached_tests[$field_assetid])) {
			$db =& $GLOBALS['SQ_SYSTEM']->db;

			$sql = 'SELECT
						COUNT(*)
					FROM
						'.SQ_TABLE_RUNNING_PREFIX.'ast_typ_inhd ati
							JOIN '.SQ_TABLE_RUNNING_PREFIX.'ast a ON ati.type_code = a.type_code';
			$where = 'a.assetid = '.$db->quoteSmart($field_assetid).'
						AND	ati.inhd_type_code	= '.$db->quoteSmart('metadata_field');
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'a');
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'ati');

			$count = $db->getOne($sql.$where);
			assert_valid_db_result($count);
			$cached_tests[$field_assetid] = ($count > 0);
		}

		return $cached_tests[$field_assetid];

	}//end isMetadataFieldAssetid()


	/**
	* Returns whether the asset ID being passed into this function is some kind
	* of metadata field asset
	*
	* @param string	$field_assetid	the ID of the metadata field asset
	*
	* @return boolean
	* @access public
	*/
	function getMetadataFieldDefaultValue($field_assetid)
	{
		static $cached_defaults = Array();
		if (!in_array($field_assetid, array_keys($cached_defaults))) {
			if (!$this->isMetadataFieldAssetid($field_assetid)) {
				trigger_localised_error('SYS0308', E_USER_WARNING, $field_assetid);
			}

			$db =& $GLOBALS['SQ_SYSTEM']->db;

			$sql = 'SELECT
						default_val
					FROM
						'.SQ_TABLE_RUNNING_PREFIX.'ast_mdata_dflt_val mdv';
			$where = 'mdv.assetid = '.$db->quoteSmart($field_assetid);
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'mdv');

			// if not found, getOne() will return null
			$default_val = $db->getOne($sql.$where);
			assert_valid_db_result($default_val);
			$cached_defaults[$field_assetid] = $default_val;
		}

		return $cached_defaults[$field_assetid];

	}//end getMetadataFieldDefaultValue()


	/**
	* Sets the default value of a certain metadata field asset (as identified
	* by assetid)
	*
	* @param string	$field_assetid	the ID of the metadata field asset
	* @param string	$value			the value to be stored
	*
	* @return boolean
	* @access public
	*/
	function setMetadataFieldDefaultValue($field_assetid, $value)
	{
		// is this actually a metadata field or what?!
		if (!$this->isMetadataFieldAssetid($field_assetid)) {
			trigger_localised_error('SYS0308', E_USER_WARNING, $field_assetid);
		}

		$db =& $GLOBALS['SQ_SYSTEM']->db;

		$sql = 'SELECT
					default_val
				FROM
					'.SQ_TABLE_RUNNING_PREFIX.'ast_mdata_dflt_val mdv';
		$where = 'mdv.assetid = '.$db->quoteSmart($field_assetid);
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'mdv');

		$row = $db->getRow($sql.$where);
		assert_valid_db_result($row);

		// does the default value exist yet, then?
		if (is_null($row)) {
			$sql = 'INSERT INTO
						sq_ast_mdata_dflt_val
						(
							assetid,
							default_val
						)
					VALUES
						(
							'.$db->quoteSmart($field_assetid).',
							'.$db->quoteSmart($value).'
						)';
		} else {
			$sql = 'UPDATE
						sq_ast_mdata_dflt_val
					SET
						default_val = '.$db->quoteSmart($value).'
					WHERE
						assetid = '.$db->quoteSmart($field_assetid);
		}

		$value = $db->query($sql);
		assert_valid_db_result($value);

		return true;

	}//end setMetadataFieldDefaultValue()


}//end class

?>
