<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Open Source Licence                                      |
* +--------------------------------------------------------------------+
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +--------------------------------------------------------------------+
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +--------------------------------------------------------------------+
*
* $Id: metadata_manager.inc,v 1.54.2.3 2005/05/17 07:06:22 lwright Exp $
* $Name: not supported by cvs2svn $
*/


/**
* Metadata_Manager
*
* Purpose
*    Manages the editing of metadata in the system
*
* @author  Greg Sherwood <greg@squiz.net>
* @version $Version$ - 1.0
* @package MySource_Matrix
*/
require_once SQ_FUDGE_PATH.'/general/text.inc';

class Metadata_Manager extends MySource_Object
{

	/**
	* Constructor
	*
	*/
	function Metadata_Manager()
	{
		$this->MySource_Object();

	}//end constructor


	/**
	* Check if all required fields have been completed for an asset
	*
	* If no values have been entered, the default schema values are checked
	*
	* @param string	$assetid	the ID of the asset to check
	*
	* @access public
	* @return boolean
	*/
	function requiredFieldsComplete($assetid)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) return true;

		$schemas = $this->getSchemas($asset->id, true);
		if (empty($schemas)) return true;

		foreach ($schemas as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) continue;
			if (!is_a($schema, 'metadata_schema')) continue;
			$edit_fns = $schema->getEditFns();
			$values = $this->getSchemaMetadata($asset->id, $schema->id, true);
			if (!$edit_fns->requiredFieldsComplete($schema, $values)) return false;
		}

		return true;

	}//end requiredFieldsComplete()


	/**
	* Check if all required fields have been completed for an asset
	*
	* @param string	$assetid	the ID of the asset to check
	*
	* @access public
	* @return boolean
	*/
	function allowsMetadata($assetid)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) return false;
		$edit_fns = $asset->getEditFns();
		return isset($edit_fns->static_screens['metadata']);

	}//end allowsMetadata()


//--        SCHEMAS        --//


	/**
	* Get an array of schemaIDs for all schemas applied and denied on an asset
	*
	* @param string		$assetid	the ID of the asset to get schemas for
	* @param boolean	$granted	type of access : null = all, true = applied, false = denied
	*
	* @access public
	* @return array( schemaid => granted[1|0] )
	*/
	function getSchemas($assetid, $granted=null)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$sql = '  SELECT DISTINCT schemaid, granted
				  FROM '.SQ_TABLE_RUNNING_PREFIX.'ast_metadata ';
		$where = 'assetid = '.$db->quote($assetid);
		if (!is_null($granted)) $where .= ' AND granted = '.$db->quote((($granted) ? '1' : '0'));
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

		$result = $db->getAll($sql.$where);
		if (DB::isError($result)) {
			trigger_error($result->getMessage().'<br/>'.$result->getUserInfo(), E_USER_WARNING);
			return Array();
		}

		$schemas = Array();
		foreach ($result as $data) {
			if (is_null($granted)) $schemas[$data['schemaid']] = $data['granted'];
			else $schemas[] = $data['schemaid'];
		}

		return $schemas;

	}//end getSchemas()


	/**
	* Apply a schema to or Deny from, an asset
	*
	* @param string		$assetid	the ID of the asset to set the schema on
	* @param string		$schemaid	the ID of the schema to set
	* @param boolean	$granted	is this schema applied (TRUE) or denied (FALSE)?
	*
	* @access public
	* @return boolean
	*/
	function setSchema($assetid, $schemaid, $granted)
	{
		$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_error('Failed setting metadata schema, Schema Asset #'.$schemaid.' does not exist', E_USER_WARNING);
			return false;
		}

		if (!is_a($schema, 'metadata_schema')) {
			trigger_error('Failed setting metadata schema, "'.$schema->name.'" (Asset #'.$schemaid.') is not a metadata schema', E_USER_WARNING);
			return false;
		}

		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_error('Failed setting metadata schema, Asset #'.$assetid.' does not exist', E_USER_WARNING);
			return false;
		}

		if (!$asset->adminAccess('metadata')) {
			trigger_error('Cannot set metadata schema for "'.$asset->name.'", permission denied', E_USER_WARNING);
			return false;
		}

		// get the current schemas that are set
		$schemas = $this->getSchemas($assetid);

		// check if this schema is already set
		if (isset($schemas[$schemaid])) {
			if ((bool)$schemas[$schemaid] == $granted) {
				// schema is set with same access level
				return true;
			} else {
				// schema is set but with the opposite access level
				$new_access     = ($granted) ? 'apply'  : 'deny';
				$current_access = ($granted) ? 'denied' : 'applied';

				trigger_error('Could not '.$new_access.' metadata schema "'.$schema->name.'" on "'.$asset->name.'" because this asset already has this schema '.$current_access, E_USER_WARNING);
				return false;
			}
		}

		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		// add the schema to the database
		$values = Array('assetid'  => $asset->id,
						'schemaid' => $schemaid,
						'metadata' => '',
						'granted'  => (($granted) ? '1' : '0')
						);
		if (!$GLOBALS['SQ_SYSTEM']->rollbackInsert('ast_metadata', $values)) {
			$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
			return false;
		}

		// add defaults to the indexing service
		if ($granted) {
			$em =& $GLOBALS['SQ_SYSTEM']->getEventManager();
			$em->broadcastEvent($asset, 'indexMetadata', Array('assetid' => $asset->id, 'schemaids' => Array($schemaid)));
			$this->generateContentFile($assetid, false);
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		return true;

	}//end setSchema()


	/**
	* Remove a set schema from an asset
	*
	* @param string	$assetid	the ID of the asset to delete the schema from
	* @param string	$schemaid	the ID of the schema to delete
	*
	* @access public
	* @return boolean
	*/
	function deleteSchema($assetid, $schemaid)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_error('Failed deleting metadata schema, Asset #'.$assetid.' does not exist', E_USER_WARNING);
			return false;
		}

		if (!$asset->adminAccess('metadata')) {
			trigger_error('Cannot delete metadata schema for "'.$asset->name.'", permission denied', E_USER_WARNING);
			return false;
		}

		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		// delete and add rollback entries
		$where = 'schemaid    = '.$db->quote($schemaid).'
				  AND assetid = '.$db->quote($asset->id);
		if (!$GLOBALS['SQ_SYSTEM']->rollbackDelete('ast_metadata', $where)) {
			$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
			return false;
		}

		$em =& $GLOBALS['SQ_SYSTEM']->getEventManager();
		$em->broadcastEvent($asset, 'indexMetadata', Array('assetid' => $asset->id, 'schemaids' => Array($schemaid)));
		$this->generateContentFile($assetid, false);

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		return true;

	}//end deleteSchema()


	/**
	* Get an array of assetIDs that have the passed schemaID applied or denied on them
	*
	* @param string		$schemaid	the ID of the schema to get assets for
	* @param boolean	$granted	type of access : null = all, true = applied, false = denied
	*
	* @access public
	* @return array( schemaid => granted[1|0] )
	*/
	function getSchemaAssets($schemaid, $granted=null)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$sql = '  SELECT DISTINCT assetid, granted
				  FROM '.SQ_TABLE_RUNNING_PREFIX.'ast_metadata ';
		$where = 'schemaid = '.$db->quote($schemaid);
		if (!is_null($granted)) $where .= ' AND granted = '.$db->quote((($granted) ? '1' : '0'));
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

		$result = $db->getAll($sql.$where);
		if (DB::isError($result)) {
			trigger_error($result->getMessage().'<br/>'.$result->getUserInfo(), E_USER_WARNING);
			return Array();
		}

		$assets = Array();
		foreach ($result as $data) {
			if (is_null($granted)) $assets[$data['assetid']] = $data['granted'];
			else $assets[] = $data['assetid'];
		}

		return $assets;

	}//end getSchemaAssets()


	/**
	* Get an array of metatata fields IDs for a metadata schema
	*
	* @param string $schemaid	the schema whos fields we are getting
	*
	* @return array
	* @access public
	*/
	function getMetadataFields($schemaid)
	{
		$fields_array = Array();
		$am = &$GLOBALS['SQ_SYSTEM']->am;
		$sectionids = $am->getChildren($schemaid, 'metadata_section', false);

		foreach ($sectionids as $sectionid => $section_type) {
			$fieldids = $am->getChildren($sectionid, 'metadata_field', false);
			$fields_array = array_merge($fields_array, array_keys($fieldids));
		}

		return $fields_array;

	}//end getMetadataFields()



//--        METADATA VALUES        --//


	/**
	* Get the metadata values set for an asset on a particular schema
	*
	* The arry returned may have some fields missing. If there is no field value it
	* means that the field is using the default value (whatever that happens to be
	* at the time). This cuts down on storage and allows defaults to change over time
	* without updating metadata values.
	*
	* @param string		$assetid		the ID of the asset to get metadata for
	* @param string		$schemaid		the ID of the schema to get metadata for
	* @param boolean	$allow_defaults	if this asset doesnt have metadata, should we return default values?
	*
	* @access public
	* @return array
	*/
	function getSchemaMetadata($assetid, $schemaid, $allow_defaults=false)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_error('Failed getting metadata, Asset #'.$assetid.' does not exist', E_USER_WARNING);
			return false;
		}

		$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_error('Failed getting metadata, Schema #'.$schemaid.' does not exist', E_USER_WARNING);
			return false;
		}

		if (!is_a($schema, 'metadata_schema')) {
			trigger_error('Failed getting metadata, "'.$schema->name.'" (Asset #'.$schemaid.') is not a metadata schema', E_USER_WARNING);
			return false;
		}

		// check that the schema we are getting metadata for is actually set
		$schemas = $this->getSchemas($assetid, true);
		if (!in_array($schemaid, $schemas)) return Array();

		$db = &$GLOBALS['SQ_SYSTEM']->db;

		$sql = '  SELECT metadata
				  FROM '.SQ_TABLE_RUNNING_PREFIX.'ast_metadata ';
		$where = 'assetid = '.$db->quote($asset->id).'
					AND schemaid = '.$db->quote($schemaid).'
					AND granted = 1';
		$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

		$metadata = $db->getOne($sql.$where);
		if (DB::isError($metadata)) {
			trigger_error($metadata->getMessage().'<br />'.$metadata->getUserInfo(), E_USER_WARNING);
			return Array();
		}

		$metadata = unserialize($metadata);
		if (!is_array($metadata)) $metadata = Array();

		if (empty($metadata) && $allow_defaults) {
			// no metadata is stored in the database, so get the default values
			$metadata = $this->getMetadataDefaultValues($schemaid);
		}

		return $metadata;

	}//end getSchemaMetadata()


	/**
	* Get the default metadata values for a particular schema
	*
	* @param string	$schemaid	the ID of the schema to get default metadata for
	*
	* @access public
	* @return array
	*/
	function getMetadataDefaultValues($schemaid)
	{
		$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_error('Failed getting default metadata, schema #'.$schemaid.' does not exist', E_USER_WARNING);
			return Array();
		}

		$edit_fns = $schema->getEditFns();
		return $edit_fns->getMetadataDefaultValues($schema);

	}//end getSchemaMetadata()


	/**
	* Generate an array of current values for the passed metadata field names
	*
	* If the passed fields array is empty, all field values will be returned
	*
	* @param string			$assetid	the ID of the asset to get field values for
	* @param array(string)	$fields		an array of field names
	*
	* @access public
	* @return array(field => value)
	*/
	function getMetadataFieldValues($assetid, $fields=Array())
	{
		// the array of field values we are going to return
		$field_values = Array();
		foreach ($fields as $name) $field_values[$name] = '';

		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_error('Failed generating keyword replacements, Asset #'.$assetid.' does not exist', E_USER_WARNING);
			return $field_values;
		}

		$schemas = $this->getSchemas($asset->id, true);
		if (empty($schemas)) return $field_values;

		foreach ($schemas as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) {
				trigger_error('Failed generating keyword replacements, Schema #'.$schemaid.' does not exist', E_USER_WARNING);
				return $field_values;
			}

			if (!is_a($schema, 'metadata_schema')) {
				trigger_error('Failed generating keyword replacements, "'.$schema->name.'" (Asset #'.$schemaid.') is not a metadata schema', E_USER_WARNING);
				return $field_values;
			}

			$values = $this->getSchemaMetadata($asset->id, $schema->id, true);
			// if they didnt supply specific fields, they want the lot
			if (empty($fields)) {
				if (isset($values['sections'])) {
					foreach ($values['sections'] as $section_name => $section_fields) {
						foreach ($section_fields['fields'] as $field_name => $default) $field_values[$field_name] = '';
					}
				}
			}

			$edit_fns = $schema->getEditFns();
			$edit_fns->getMetadataFieldValues($asset, $schema, $values, $field_values);
		}

		return $field_values;

	}//end getMetadataFieldValues()


	/**
	* Set metadata values for an asset
	*
	* @param string	$assetid	the ID of the asset to set the values for
	* @param array	$metadata	the values to set
	*
	* @access public
	* @return boolean
	*/
	function setMetadata($assetid, $metadata)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_error('Failed setting metadata, Asset #'.$assetid.' does not exist', E_USER_WARNING);
			return false;
		}

		if (!$asset->writeAccess('metadata')) {
			trigger_error('Cannot set metadata for "'.$asset->name.'", permission denied', E_USER_WARNING);
			return false;
		}

		$schemaids = $this->getSchemas($asset->id, true);
		if (empty($schemaids)) return false;


		foreach ($schemaids as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (!isset($metadata[$schema->name])) continue;
			if (false === ($this->setSchemaMetadata($assetid, $schemaid, $metadata[$schema->name]))) return false;
		}

		$em =& $GLOBALS['SQ_SYSTEM']->getEventManager();
		$em->broadcastEvent($asset, 'indexMetadata', Array('assetid' => $assetid, 'schemaids' => $schemaids));

		return true;

	}//end setMetadata()


	/**
	* sets metadata for an asset that is specific to a schema
	*
	* @param string	$assetid	the assetid to apply the schema for
	* @param string	$schemaid	the id of the schema to apply the metadata to
	* @param array		$metadata	the metadata values to set
	*
	* @return boolean
	* @access public
	*/
	function setSchemaMetadata($assetid, $schemaid, $metadata)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);

		if (is_null($schema)) {
			trigger_error('Failed setting metadata, Schema #'.$schemaid.' does not exist', E_USER_WARNING);
			$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
			return false;
		}

		if (!is_a($schema, 'metadata_schema')) {
			trigger_error('Failed setting metadata, "'.$schema->name.'" (Asset #'.$schemaid.') is not a metadata schema', E_USER_WARNING);
			$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
			return false;
		}

		$values = Array('metadata' => $db->quote(serialize($metadata)));
		$where = 'assetid = '.$db->quote($asset->id).'
					AND schemaid = '.$db->quote($schema->id);
		if (!$GLOBALS['SQ_SYSTEM']->rollbackUpdate('ast_metadata', $values, $where)) {
			$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
			return false;
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');

		return true;

	}//end setSchemaMetadata()



//--        (RE)GENERATE METADATA        --//


	/**
	* Generate a PHP file that can be included to print all metadata fields for an asset
	*
	* The generated file contains PHP code to do any keyword replacing based on
	* current values instead of the ones at the time of caching.
	*
	* @param string		$assetid		the ID of the asset to generate the file for
	* @param booelan	$regenerate		regenerate the DB information as well
	*
	* @access public
	* @return boolean
	*/
	function generateContentFile($assetid, $regenerate=false)
	{
		$asset = &$GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_error('Failed caching metadata, Asset #'.$assetid.' does not exist', E_USER_WARNING);
			return false;
		}

		$schemas = $this->getSchemas($asset->id, true);
		if (empty($schemas)) return false;

		// an array of all metadata tag values
		$tag_values = Array();

		// an array of keyword replacements that we are going to have to write some PHP code to produce
		$keywords = Array();

		// an array to hold the complete DB metadata if we are regenerating
		$db_metadata = Array();

		ob_start();
		foreach ($schemas as $schemaid) {
			$schema = &$GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) {
				trigger_error('Failed caching metadata, Schema #'.$schemaid.' does not exist', E_USER_WARNING);
				return false;
			}

			if (!is_a($schema, 'metadata_schema')) {
				trigger_error('Failed caching metadata, "'.$schema->name.'" (Asset #'.$schemaid.') is not a metadata schema', E_USER_WARNING);
				return false;
			}

			$values = Array();
			$values = $this->getSchemaMetadata($asset->id, $schema->id);
			$edit_fns = $schema->getEditFns();
			$edit_fns->generateMetadata($schema, $values, $tag_values, $keywords);
			if ($regenerate) $db_metadata[$schema->name] = $values;

			$GLOBALS['SQ_SYSTEM']->am->forgetAsset($schema);
		}

		$metadata = ob_get_contents();
		ob_end_clean();

		ob_start();
			echo '<'.'?php'."\n";

			if (!empty($keywords)) {
				require_once SQ_FUDGE_PATH.'/general/text.inc';
				echo '$metadata_asset = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset('.$asset->id.');'."\n\n";
				$replacements = $this->generateKeywordReplacements($asset, $keywords);
				$tag_values = replace_keywords($tag_values, $replacements);
				echo "\n\n";
			}

			$nested_tag_values = Array();
			$tag_nested_index = Array();
			foreach ($tag_values as $n => $v) {
				$matches = Array();
				$nested_index = 0;
				preg_match_all('|\$metadata_values\[\'([^\]]+)\'\]|', $v, $matches);
				if (!empty($matches[1])) {
					foreach ($matches[1] as $field_name) {
						// we have a nested field name
						for ($i = 0; $i < count($nested_tag_values); $i++) {
							if (isset($nested_tag_values[$i][$field_name])) {
								$v = preg_replace('|(\$metadata_values)(\[\')('.$field_name.')(\'\])|', '$metadata_values_'.$i.'[\'\\3\']', $v);
								if ($i >= $nested_index) $nested_index = $i + 1;
								break;
							}
						}
					}
				}

				$nested_tag_values[$nested_index][$n] = $v;
				$tag_nested_index[$n] = $nested_index;
			}

			foreach ($nested_tag_values as $i => $values) {
				echo '$metadata_values_'.$i.' = Array(';
				foreach ($values as $n => $v) {
					$v = stripslashes($v);
					$v = preg_replace('%\'%', '\\\'', $v);
					$v = preg_replace('%\"%', '&quot;', $v);
					$v = preg_replace('|(\$metadata_replacements\[)\\\\\'([^\]]+)\\\\\'(\])|', '\'.\\1\'\\2\'\\3.\'', $v);
					$v = preg_replace('|(\$metadata_values[^\[]+\[)\\\\\'([^\]]+)\\\\\'(\])|', '\'.\\1\'\\2\'\\3.\'', $v);
					echo "'$n' => '$v',\n";
				}
				echo ");\n";
			}

			echo '?'.'>';
			$php = ob_get_contents();
		ob_end_clean();

		$metadata_matches = Array();
		preg_match_all('|\$metadata_values\[\'([^\]]+)\'\]|', $metadata, $metadata_matches);
		foreach ($metadata_matches[1] as $field_name) {
			$metadata = preg_replace('|\$metadata_values\[\''.$field_name.'\'\]|', '$metadata_values_'.$tag_nested_index[$field_name].'[\''.$field_name.'\']', $metadata);
		}

		$metadata = $php."\n\n".$metadata;

		require_once SQ_FUDGE_PATH.'/general/file_system.inc';
		create_directory($asset->data_path);
		if (!string_to_file($metadata, $asset->data_path.'/metadata.php')) return false;

		if (!$regenerate) return true;
		else return $this->setMetadata($assetid, $db_metadata);

	}//end generateContentFile()


	/**
	* Generate PHP code to replace a set of keywords
	*
	* This function outputs the PHP required to generate all the keywords that
	* it is passed. All PHP generated places values in an array called $metadata_replacements
	* (which happens in the outputted PHP code). An array of replacements is returned that
	* can be used to replace all the keywords with a PHP string to output the correct value
	* from the $metadata_replacements array.
	*
	* This function can also return the values of the replacement values instead of the PHP code.
	*
	* @param object Asset	&$asset		the asset to use for replacment values
	* @param array			$keywords	an array of keywords in
	* @param boolean		$generating	generate the PHP code or not (which generates the value)
	*
	* @access public
	* @return array(keyword => replacement)
	*/
	function generateKeywordReplacements(&$metadata_asset, $keywords, $generating=true)
	{
		$metadata_replacements = Array();
		$keywords = array_unique($keywords);

		if (!empty($keywords) && $generating) echo '$metadata_replacements = Array();'."\n";

		foreach ($keywords as $keyword) {

			if ($generating) {
				$metadata_replacements[$keyword] = '$metadata_replacements[\''.$keyword.'\']';
			} else {
				ob_start();
			}

			switch ($keyword) {

				case 'asset_name'       :
				case 'asset_short_name' :
				case 'asset_version'    :
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_asset->'.substr($keyword,6).';'."\n";
				break;

				case 'asset_url' :
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_asset->getURL();'."\n";
				break;

				case 'asset_href' :
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_asset->getHref();'."\n";
				break;

				case 'asset_thumbnail' :
					echo 'if ($metadata_asset->id) {';
					echo '$link = $GLOBALS[\'SQ_SYSTEM\']->am->getLink($metadata_asset->id, SQ_LINK_NOTICE, \'thumbnail\', true, \'thumbnail\');'."\n";
					echo 'if (!empty($link)) {'."\n";
					echo '$thumbnail = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($link[\'minorid\']);'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = $thumbnail->printImageTag($metadata_asset->name, true);'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'\';'."\n";
					echo '}'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'\';'."\n";
					echo '}'."\n";
				break;

				case 'asset_created' :
				case 'asset_updated' :
					echo '$metadata_replacements[\''.$keyword.'\'] = date(\'Y-m-d H:i:s\', $metadata_asset->'.substr($keyword,6).');'."\n";
				break;

				case 'asset_created_short' :
				case 'asset_updated_short' :
					echo '$metadata_replacements[\''.$keyword.'\'] = date(\'Y-m-d\', $metadata_asset->'.substr($keyword,6,7).');'."\n";
				break;

				case 'asset_created_readable' :
				case 'asset_updated_readable' :
					echo '$metadata_replacements[\''.$keyword.'\'] = date(\'d M Y g:ia\', $metadata_asset->'.substr($keyword,6,7).');'."\n";
				break;

				case 'asset_created_by_name' :
				case 'asset_updated_by_name' :
					echo 'if (!isset($metadata_'.substr($keyword,6,7).'_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->'.substr($keyword,6,7).'_userid));
					if (!empty($asset_info)) {
					$metadata_'.substr($keyword,6,7).'_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->'.substr($keyword,6,7).'_userid);'."\n}\n}\n";
					echo 'if (!empty($metadata_'.substr($keyword,6,7).'_by_user)) { ';
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_'.substr($keyword,6,7).'_by_user->name;'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'System\';'."\n";
					echo '}'."\n";
				break;

				case 'asset_created_by_first_name' :
				case 'asset_created_by_last_name'  :
				case 'asset_created_by_email'      :
				case 'asset_updated_by_first_name' :
				case 'asset_updated_by_last_name'  :
				case 'asset_updated_by_email'      :
					echo 'if (!isset($metadata_'.substr($keyword,6,7).'_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->'.substr($keyword,6,7).'_userid));
					if (!empty($asset_info)) {
					$metadata_'.substr($keyword,6,7).'_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->'.substr($keyword,6,7).'_userid,\'\', true);'."\n}\n}\n";
					echo 'if (!empty($metadata_'.substr($keyword,6,7).'_by_user)) { ';
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_'.substr($keyword,6,7).'_by_user->attr(\''.substr($keyword,17).'\');'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'\';'."\n";
					echo '}'."\n";

				break;

				// can't handle 'last published' stuff in the same way as created/updated because
				// there is a chance that it has never been published
				case 'asset_published' :
					echo '$metadata_replacements[\''.$keyword.'\'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'Y-m-d H:i:s\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_short' :
					echo '$metadata_replacements[\''.$keyword.'\'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'Y-m-d\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_readable' :
					echo '$metadata_replacements[\''.$keyword.'\'] = (is_null($metadata_asset->published)) ? \'Never\' : date(\'d M Y g:ia\', $metadata_asset->published);'."\n";
				break;

				case 'asset_published_by_name' :
					echo 'if (is_null($metadata_asset->published_userid)) {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'Never Published\';'."\n";
					echo '} else { if (!isset($metadata_published_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->published_userid));
					if (!empty($asset_info)) {
					$metadata_published_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->published_userid);'."\n}\n}\n";
					echo 'if (!empty($metadata_published_by_user)) { ';
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_published_by_user->name;'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'System\';'."\n";
					echo '}}'."\n";
				break;

				case 'asset_published_by_first_name' :
				case 'asset_published_by_last_name'  :
				case 'asset_published_by_email'      :
					echo 'if (is_null($metadata_asset->published_userid)) {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'\';'."\n";
					echo '} else { if (!isset($metadata_published_by_user)) {
					$asset_info = $GLOBALS[\'SQ_SYSTEM\']->am->getAssetInfo(Array($metadata_asset->published_userid));
					if (!empty($asset_info)) {
					$metadata_published_by_user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($metadata_asset->published_userid);'."\n}\n}\n";
					echo 'if (!empty($metadata_published_by_user)) { ';
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_published_by_user->attr(\''.substr($keyword,19).'\');'."\n";
					echo '} else {'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = \'\';'."\n";
					echo '}}'."\n";

				break;

				case 'asset_read_permission'  :
				case 'asset_write_permission' :
				case 'asset_admin_permission' :
					$perm_type = str_replace('_permission', '', $keyword);
					$perm_type = substr($perm_type,6);
					echo '$metadata_'.$perm_type.'_perms = $GLOBALS[\'SQ_SYSTEM\']->am->getPermission($metadata_asset->id, SQ_PERMISSION_'.strtoupper($perm_type).', true, false, true);'."\n";
					echo '$metadata_'.$perm_type.'_perm_names = \'\';'."\n";
					echo 'foreach ($metadata_'.$perm_type.'_perms as $userid) {'."\n";
					echo '	$user = &$GLOBALS[\'SQ_SYSTEM\']->am->getAsset($userid);'."\n";
					echo '	if (is_null($user)) continue;'."\n";
					echo '	$metadata_'.$perm_type.'_perm_names .= $user->name.\', \';'."\n";
					echo '}'."\n";
					echo '$metadata_'.$perm_type.'_perm_names = trim($metadata_'.$perm_type.'_perm_names, \', \');'."\n";
					echo '$metadata_replacements[\''.$keyword.'\'] = $metadata_'.$perm_type.'_perm_names;'."\n";
				break;

				case 'system_name'   :
				case 'system_owner'  :
				case 'default_email' :
				case 'tech_email'    :
					echo '$metadata_replacements[\''.$keyword.'\'] = SQ_CONF_'.strtoupper($keyword).';'."\n";
				break;

				default :

					// searching for keywords that replace the content of another field
					if (substr($keyword, 0, 15) == 'metadata_field_') {

						$field_name = substr($keyword, 15);
						$metadata_replacements[$keyword] = '$metadata_values[\''.$field_name.'\']';

					} else {

						// searching for special date format keywords
						$keyword = substr($keyword, 6);
						$key = substr($keyword, 0, strpos($keyword, '_'));
						$extras = substr($keyword, strpos($keyword, '_') +1);

						if (strpos($extras, '_') === false) {
							$format = $extras;
							$offset = '';
						} else {
							list ($format, $offset) = explode('_', $extras);
						}
						$format = str_replace('~', ' ', $format);

						switch ($key) {
							case 'created':
							case 'updated':
							case 'published':
								if (empty($offset)) $date = '$metadata_asset->'.$key;
								else $date = 'strtotime(\''.$offset.'\', $metadata_asset->'.$key.')';

								echo '$metadata_replacements[\'asset_'.$key.'\'] = date(\''.$format.'\', '.$date.');'."\n";
							break;
							default:
								echo '$metadata_replacements[\'asset_'.$key.'\'] = \'\';'."\n";
							break;
						}

					}//end if

				break;

			}//end switch


			if (!$generating) {
				eval(ob_get_contents());
				ob_end_clean();
			}
		}

		return $metadata_replacements;

	}//end generateKeywordReplacements()


	/**
	* Regenerate both the cached tag metadata and the serialised DB values
	*
	* @param string	$assetid	the ID of the asset to regenerate metadata for
	*
	* @access public
	* @return boolean
	*/
	function regenerateMetadata($assetid)
	{
		return $this->generateContentFile($assetid, true);

	}//end regenerateMetadata()


	/**
	* Removes the metadata entries for the specified asset
	*
	* @param string	$assetid	the assetid of the asset to purge
	*
	* @return boolean
	* @access public
	*/
	function purgeMetadata($assetid)
	{
		$db = &$GLOBALS['SQ_SYSTEM']->db;
		$where_cond = 'assetid='.$db->quote($assetid);

		return $GLOBALS['SQ_SYSTEM']->rollbackDelete('ast_metadata', $where_cond);

	}//end purgeMetadata()


}//end class

?>
