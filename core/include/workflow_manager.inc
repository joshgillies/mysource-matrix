<?php
/**
* +--------------------------------------------------------------------+
* | This MySource Matrix CMS file is Copyright (c) Squiz Pty Ltd       |
* | ACN 084 670 600                                                    |
* +--------------------------------------------------------------------+
* | IMPORTANT: Your use of this Software is subject to the terms of    |
* | the Licence provided in the file licence.txt. If you cannot find   |
* | this file please contact Squiz (www.squiz.net) so we may provide   |
* | you a copy.                                                        |
* +--------------------------------------------------------------------+
*
* $Id: workflow_manager.inc,v 1.106.2.1 2007/09/13 01:39:12 bshkara Exp $
*
*/


/**
* Workflow_Manager
*
* Purpose
*    Facilitate the managment of workflow for assets
*
* @author  Greg Sherwood <greg@squiz.net>
* @version $Revision: 1.106.2.1 $
* @package MySource_Matrix
*/
class Workflow_Manager extends MySource_Object
{

	/**
	* Logic operators require the right operands
	*
	* @var array
	*/
	var $_valid_logic_with_right_operand = Array('>=');

	/**
	* Logic strings that are valid for steps
	*
	* @var array
	*/
	var $_valid_step_logic = Array('>='  => 'At least', 'all' => 'All');

	/**
	* Logic strings that are valid for conditions
	*
	* @var array
	*/
	var $_valid_cond_logic = Array('>=' => 'At least', 'all' => 'All');


	/**
	* Constructor
	*
	*/
	function Workflow_Manager()
	{
		$this->MySource_Object();

	}//end constructor


	/**
	* Get an array of schemaIDs for all schemas applied and denied on an asset
	* Can also optionally get running workflows only.
	*
	* Return value: Array( schemaid => granted[1|0] ) if $granted is null
	*	OR array(schemaid) if it is set
	*
	* @param int		$assetid	the ID of the asset to get schemas for
	* @param boolean	$granted	type of access : null = all, true = applied, false = denied
	* @param boolean	$running	only getting running workflows
	*
	* @return array
	* @access public
	*/
	function getSchemas($assetid, $granted=NULL, $running=FALSE)
	{
		$storage_access = ((is_null($granted)) ? 2 : (int) $granted);
		if (!isset($this->_tmp['schemas'][(int)$assetid][$storage_access][(int)$running])) {
			$db =& $GLOBALS['SQ_SYSTEM']->db;

			$sql = '  SELECT DISTINCT schemaid, granted
					  FROM '.SQ_TABLE_RUNNING_PREFIX.'ast_wflow ';
			$where = 'assetid = '.$db->quote($assetid);
			if ($running) $where .= ' AND wflow IS NOT NULL';
			if (!is_null($granted) || $running) {
				$where .= ' AND granted = '.$db->quote((($granted) ? '1' : '0'));
			}
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

			$result = $db->getAll($sql.$where);
			assert_valid_db_result($result);

			$schemas = Array();
			foreach ($result as $data) {
				if (is_null($granted)) {
					$schemas[$data['schemaid']] = $data['granted'];
				} else {
					$schemas[] = $data['schemaid'];
				}
			}

			$this->_tmp['schemas'][(int)$assetid][$storage_access][(int)$running] = $schemas;
		}

		return $this->_tmp['schemas'][(int)$assetid][$storage_access][(int)$running];

	}//end getSchemas()


	/**
	* Apply a schema to or Deny from, an asset
	*
	* @param int		$assetid	the ID of the asset to set the schema on
	* @param int		$schemaid	the ID of the schema to set
	* @param boolean	$granted	is this schema applied (TRUE) or denied (FALSE)?
	* @param boolean	$force_set	if true, existing workflow schemas will be updated regardless of whether or not the new workflow schemas are found to conflict with them
	*
	* @return boolean
	* @access public
	*/
	function setSchema($assetid, $schemaid, $granted, $force_set=FALSE)
	{
		$assetid  = (int)  $assetid;
		$schemaid = (int)  $schemaid;
		$granted  = (bool) $granted;
		$db_action = 'insert';

		$schema =& $GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_localised_error('SYS0175', E_USER_WARNING, $schemaid);
			return FALSE;
		}

		if (!is_a($schema, 'workflow_schema')) {
			trigger_localised_error('SYS0173', E_USER_WARNING, $schema->name, $schemaid);
			return FALSE;
		}

		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0174', E_USER_WARNING, $assetid);
			return FALSE;
		}

		if (!$asset->adminAccess('workflow')) {
			trigger_localised_error('SYS0117', E_USER_WARNING, $asset->name);
			return FALSE;
		}

		// check for any running schemas - because if the asset is in workflow we cant do anything
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (!empty($running_schemas)) {
			trigger_localised_error('SYS0118', E_USER_WARNING, $asset->name);
			return FALSE;
		}

		// get the current schemas that are set
		$schemas = $this->getSchemas($assetid);
		// check if this schema is already set
		if (isset($schemas[$schemaid])) {
			if ((bool)$schemas[$schemaid] == $granted) {
				// schema is set with same access level
				return TRUE;
			} else {
				if ($force_set) {
					$db_action = 'update';
				} else {
					// schema is set but with the opposite access level
					$new_access     = ($granted) ? 'apply'  : 'deny';
					$current_access = ($granted) ? 'denied' : 'applied';

					trigger_localised_error('SYS0124', E_USER_WARNING, $new_access, $schema->name, $asset->name, $current_access);
					return FALSE;
				}
			}
		}

		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		switch ($db_action) {
			case 'insert':
				$sql = 'INSERT INTO
						sq_ast_wflow
						(
							assetid,
							schemaid,
							wflow,
							granted
						)
						VALUES
						(
							'.$db->quoteSmart((string)$assetid).',
							'.$db->quoteSmart((string)$schemaid).',
							NULL,
							'.$db->quoteSmart(($granted) ? '1' : '0').'
						)';
			break;
			case 'update':
				$sql = 'UPDATE
								sq_ast_wflow
							SET
								granted = '.$db->quoteSmart(($granted) ? '1' : '0').'
							WHERE
								assetid = '.$db->quoteSmart((string)$assetid).'
							AND
								schemaid  = '.$db->quoteSmart((string)$schemaid);

			break;
		}

		$result = $db->query($sql);
		assert_valid_db_result($result);

		unset($this->_tmp['schemas'][(int)$assetid]);
		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();

		return TRUE;

	}//end setSchema()


	/**
	* Remove a set schema from an asset
	*
	* @param int	$assetid	the ID of the asset to delete the schema from
	* @param int	$schemaid	the ID of the schema to delete
	*
	* @return boolean
	* @access public
	*/
	function deleteSchema($assetid, $schemaid)
	{
		$assetid  = (int) $assetid;
		$schemaid = (int) $schemaid;

		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0153', E_USER_WARNING, $assetid);
			return FALSE;
		}

		if (!$asset->adminAccess('workflow')) {
			trigger_localised_error('SYS0105', E_USER_WARNING, $asset->name);
			return FALSE;
		}

		// check for any running schemas - because if the asset is in workflow we cant do anything
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (!empty($running_schemas)) {
			trigger_localised_error('SYS0106', E_USER_WARNING, $asset->name);
			return FALSE;
		}

		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'DELETE FROM
					sq_ast_wflow
				WHERE
					schemaid	= '.$db->quoteSmart($schemaid).'
				AND	assetid		= '.$db->quoteSmart($asset->id);

		$result = $db->query($sql);
		assert_valid_db_result($result);

		unset($this->_tmp['schemas'][(int)$assetid]);
		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();

		return TRUE;

	}//end deleteSchema()


	/**
	* Get the workflow values set for an asset on a particular schema or all schemas
	*
	* Return value: Array( schemaid => workflow_array )
	*
	* @param int	$assetid	the ID of the asset to get workflow for
	* @param int	$schemaid	the ID of the schema to get workflow for (NULL for all workflows)
	*
	* @return array
	* @access public
	* @see Asset::useSystemVersion()
	*/
	function getSchemaWorkflows($assetid, $schemaid='all')
	{
		$assetid = (int) $assetid;

		if ($schemaid != 'all') {
			// we are looking for a specific schema, but we might already have
			// the information we need in the 'all' array
			if (isset($this->_tmp['schema_workflows'][$assetid]['all'][$schemaid])) {
				$this->_tmp['schema_workflows'][$assetid][$schemaid] = $this->_tmp['schema_workflows'][$assetid]['all'][$schemaid];
			}
		}

		if (!isset($this->_tmp['schema_workflows'][$assetid][$schemaid])) {

			$db =& $GLOBALS['SQ_SYSTEM']->db;

			$sql = 'SELECT
						schemaid, wflow
					FROM
						'.SQ_TABLE_RUNNING_PREFIX.'ast_wflow ';

			$where = 'assetid = '.$db->quote($assetid).'
						AND granted = 1';

			if ($schemaid != 'all') {
				$where .= ' AND schemaid = '.$db->quote($schemaid);
			}
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where);

			$workflows = $db->getAssoc($sql.$where, FALSE, Array(), DB_FETCHMODE_ASSOC);
			assert_valid_db_result($workflows);

			for (reset($workflows); NULL !== ($k = key($workflows)); next($workflows)) {
				$workflows[$k] = (is_null($workflows[$k])) ? '' : unserialize($workflows[$k]);
			}

			if ($schemaid == 'all') {
				$this->_tmp['schema_workflows'][$assetid]['all'] = $workflows;
			} else {
				$this->_tmp['schema_workflows'][$assetid][$schemaid] = $workflows[$schemaid];
			}
		}

		if (!isset($this->_tmp['schema_workflows'][$assetid][$schemaid])) {
			return Array();
		}

		return $this->_tmp['schema_workflows'][$assetid][$schemaid];

	}//end getSchemaWorkflows()


	/**
	* Set workflow values for an asset
	*
	* @param int	$assetid	the ID of the asset to set the values for
	* @param array	$workflow	the values to set
	*
	* @return boolean
	* @access public
	*/
	function setWorkflow($assetid, $workflow)
	{
		$assetid = (int) $assetid;

		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0177', E_USER_WARNING, $assetid);
			return FALSE;
		}

		if (!$asset->adminAccess('workflow')) {
			trigger_localised_error('SYS0117', E_USER_WARNING, $asset->name);
			return FALSE;
		}

		$schemas = $this->getSchemas($asset->id, TRUE);
		if (empty($schemas)) return FALSE;

		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'UPDATE
					sq_ast_wflow
				SET
					wflow	= ?
				WHERE
						assetid		= ?
					AND	schemaid	= ?';

		$prepared = $db->prepare($sql);
		assert_valid_db_result($prepared);

		foreach ($schemas as $schemaid) {
			$schema =& $GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
			if (is_null($schema)) {
				trigger_localised_error('SYS0174', E_USER_WARNING, $schemaid);
				$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
				$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();
				return FALSE;
			}

			if (!is_a($schema, 'workflow_schema')) {
				trigger_localised_error('SYS0176', E_USER_WARNING, $schema->name, $schemaid);
				$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
				$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();
				return FALSE;
			}

			if (!isset($workflow[$schema->name])) continue;

			$values = Array(
						serialize($workflow[$schema->name]),
						$asset->id,
						$schema->id,
					  );

			$result = $db->execute($prepared, $values);
			assert_valid_db_result($result);

			$this->_tmp['schema_workflows'][$assetid][$schemaid] = $workflow[$schema->name];
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();
		return TRUE;

	}//end setWorkflow()


	/**
	* Returns an array of all users who can publish one of the running workflows
	*
	* The publishers are based on the current step in the workflow
	* so the users returned are only users who will affect the workflow at this point.
	*
	* @param int		$assetid	the ID of the asset to get publishers for
	* @param int		$schemaid	the schema to get publishers for
	* @param boolean	$group		group the return value by workflowid
	*
	* @return array
	* @access public
	*/
	function whoCanPublish($assetid, $schemaid=NULL, $group=FALSE)
	{
		// if there are no current workflows running, we are not waiting for anyone
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (empty($running_schemas)) return Array();

		// these will be the people who can approve this asset
		// at this point in the workflow
		$can_publish = Array();

		foreach ($running_schemas as $sid) {
			if (!is_null($schemaid) && $sid != $schemaid) {
				continue;
			}
			if ($group) {
				$can_publish[$sid] = $this->_whoCanPublishWorkflow($assetid, $sid);
				$can_publish[$sid] = array_unique($can_publish[$sid]);
			} else {
				$can_publish = array_merge($can_publish, $this->_whoCanPublishWorkflow($assetid, $sid));
			}
		}

		if (!$group) $can_publish = array_unique($can_publish);
		return $can_publish;

	}//end whoCanPublish()


	/**
	* Notifies people in the workflow that want to know when the asset goes live
	*
	* @param int	$assetid	the ID of the asset that has gone live
	* @param int	$old_status	the status the asset is changing from
	*
	* @return boolean
	* @access public
	*/
	function notifyOnLive($assetid, $old_status)
	{
		// we dont have to notify people for silent workflow assets
		if ($this->silentWorkflowParty($assetid)) return TRUE;

		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0180', E_USER_WARNING, $assetid);
			return FALSE;
		}

		// if there are no workflows, we dont notify anyone
		$schemas = $this->getSchemas($assetid, TRUE);
		if (empty($schemas)) return TRUE;

		// these will be the people who to notify (some may be groups)
		$notify = Array();

		foreach ($schemas as $schemaid) {
			$conditions = $GLOBALS['SQ_SYSTEM']->am->getChildren($schemaid, 'workflow_step_condition');
			foreach ($conditions as $cond_id => $type_code) {
				$condition =& $GLOBALS['SQ_SYSTEM']->am->getAsset($cond_id, 'workflow_step_condition');
				if (is_null($condition)) continue;
				if ($condition->attr('notify')) {
					// check if this is a roleid rather than a user_groupid or userid
					$role = $GLOBALS['SQ_SYSTEM']->am->getRole(NULL, $condition->attr('userid'));
					if (!empty($role)) {
						$roleid = array_keys($role);
						$roleid = $roleid[0];
						// this is a roleid so get the userids in the role
						foreach ($role as $key => $value) {
							if (in_array(0, $value)) {
								// get all userids and include users which are globally applied under this role
								$role_userids = $GLOBALS['SQ_SYSTEM']->am->getRole(NULL, $roleid, NULL, FALSE, TRUE, TRUE, TRUE);
							} else {
								// get all userids and disregard globally applied users under this role
								$role_userids = $GLOBALS['SQ_SYSTEM']->am->getRole(NULL, $roleid, NULL, FALSE, FALSE, TRUE, TRUE);
							}
						}
						foreach ($role_userids as $roleid => $userids) {
							for ($i=0;$i<count($userids);$i++) {
								$notify[] = $userids[$i];
							}
						}
					} else {
						// the user or group in this condition wants to be notified
						$notify[] = $condition->attr('userid');
					}
				}
			}//end foreach
		}//end foreach

		if (!empty($notify)) {
			$notify = array_unique($notify);
			$ms =& $GLOBALS['SQ_SYSTEM']->getMessagingService();

			$msg = $ms->newMessage($notify);
			$msg->type    = 'asset.status.notify';
			$msg_reps     = Array(
								'type_code'		=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
								'asset_name'	=> $asset->name,
								'status'		=> get_status_description($old_status),
							);

			// create a link to the preview screen, or to the details screen if preview doesn't exist
			$asset_edt_fns = $asset->getEditFns();
			if (isset($asset_edt_fns->static_screens['preview'])) {
				$msg_reps['asset_url'] = current_url().$asset->getBackendHref('preview', FALSE);
			} else {
				$msg_reps['asset_url'] = current_url().$asset->getBackendHref('details', FALSE);
			}

			$msg->parameters['assetid'] = $asset->id;
			$msg->replacements          = $msg_reps;
			$ms->enqueueMessage($msg);
		}

		return TRUE;

	}//end notifyOnLive()


	/**
	* Determines whether commenting is mandatory for a particular user
	*
	* @param string	$assetid	the ID of the asset to check
	* @param string	$userid		the ID of the user to check
	*
	* @return boolean
	* @access public
	*/
	function requiresComment($assetid, $userid)
	{
		if ($this->silentWorkflowParty($assetid)) return FALSE;

		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			// TODO: Check error
			trigger_localised_error('SYS0180', E_USER_WARNING, $assetid);
			return FALSE;
		}

		// if there are no workflows, we can't require comments
		$schemas = $this->getSchemas($assetid, TRUE);
		if (empty($schemas)) return FALSE;

		$schema_workflows       = $this->getSchemaWorkflows($assetid);
		$current_workflow_steps = $this->getWorkflowCurrentSteps($assetid);

		foreach ($schemas as $schemaid) {
			// nothing in this schema, try the next
			if (empty($schema_workflows[$schemaid])) continue;

			// check to see if the step exists
			if (empty($current_workflow_steps[$schemaid])) {
				continue;
			}

			// get the current step for this schema
			$current_step =& $this->getCurrentStep($schema_workflows[$schemaid]);
			// is the user listed in the conditions?
			$listed_user = FALSE;

			// loop through the conditions for the current ste
			$condition_type_info = $GLOBALS['SQ_SYSTEM']->am->getAssetTypeInfo(array_keys($current_step['conditions']));
			foreach ($current_step['conditions'] as $conditionid => $condition_details) {
				// is a user_group
				if (in_array('user_group', $condition_type_info[$conditionid])) {
					$group_users = array_keys($GLOBALS['SQ_SYSTEM']->am->getChildren($conditionid, Array('user'), FALSE));
					if (in_array($userid, $group_users)) {
						$listed_user = TRUE;
					}
				} else {
					// assume user
					if ($conditionid == $userid) $listed_user = TRUE;
				}

				if (array_get_index($condition_details, 'require_comment', FALSE)) {
					// no point going through the rest if we know we need to comment
					return TRUE;
				}

			}

			// if the user wasn't listed, then check if unlisted users need to comment
			// if so, return: there's no point checking the rest
			if (!$listed_user && array_get_index($current_step, 'require_comment_from_unlisted_users', FALSE)) {
				return TRUE;
			}
		}//end foreach

		return FALSE;

	}//end requiresComment()


	/**
	* Returns an array of all users who can publish the running workflow for the passed schemaID
	*
	* The publishers are based on the current step in the workflow
	* so the users returned are only users who will affect the workflow at this point
	*
	* @param int	$assetid	the ID of the asset to get publishers for
	* @param int	$schemaid	the id of the schema to find publishers for
	*
	* @return array
	* @access private
	*/
	function _whoCanPublishWorkflow($assetid, $schemaid)
	{
		$am =& $GLOBALS['SQ_SYSTEM']->am;
		// these will be the people who can approve this asset at this point in the workflow
		$can_publish = Array();
		$workflow = $this->getSchemaWorkflows($assetid, $schemaid);
		if (!isset($workflow['steps'])) return Array();

		$step_data =& $this->getCurrentStep($workflow);
		if (empty($step_data)) return Array();

		for (reset($step_data['conditions']);
				NULL !== ($pub = key($step_data['conditions'])); next($step_data['conditions'])) {
			$cond_data =& $step_data['conditions'][$pub];

			// safety code
			if (!isset($cond_data['complete'])) {
				$cond_data['complete'] = FALSE;
			}
			if (!isset($cond_data['published_by'])) {
				$cond_data['published_by'] = Array();
			}

			if ($cond_data['complete']) {
				$complete = TRUE;
			} else {
				$complete = FALSE;
				$can_publish_cond = Array();

				// work out who can publish right now
				$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($pub);
				if ($asset->id) {
					$asset_class = get_class($asset);
					// Note that the order of IF statements is important, because roles are
					// a descendent of groups but should be treated differently
					if ($am->isTypeDecendant($asset_class, 'user')) {
						$can_publish_cond[] = $asset->id;
					} else if ($am->isTypeDecendant($asset_class, 'role')) {
						$roles = $GLOBALS['SQ_SYSTEM']->am->getRole($assetid, $asset->id);
						foreach ($roles as $roleid => $userids) {
							foreach ($userids as $userid) {
								if ($userid == '0') continue;
								$info = $GLOBALS['SQ_SYSTEM']->am->getAssetInfo(Array($userid), Array(), FALSE, 'type_code');
								if ($GLOBALS['SQ_SYSTEM']->am->isTypeDecendant($info[$userid], 'user_group')) {
									$can_publish_cond = array_merge($can_publish_cond, array_keys($GLOBALS['SQ_SYSTEM']->am->getChildren($userid, Array('user'), FALSE)));
								} else {
									$can_publish_cond[] = $userid;
								}
							}
						}
					} else if ($am->isTypeDecendant($asset_class, 'user_group')) {
						// getChildren with all the shadow asset children
						$can_publish_cond = array_keys($GLOBALS['SQ_SYSTEM']->am->getChildren($asset->id, Array('user'), FALSE, NULL, NULL, NULL, TRUE, NULL, NULL, FALSE));
					}
				}

				$GLOBALS['SQ_SYSTEM']->am->forgetAsset($asset);

				if ($cond_data['logic'] == 'all') {
					$cond_string = 'if ('.count($cond_data['published_by']).
								   ' >= '.count($can_publish_cond).') { $complete = true; }';
				} else {
					$cond_string = 'if ('.count($cond_data['published_by']).
								   ' '.$cond_data['logic'].') { $complete = true; }';
				}
				eval($cond_string);

			}//end else

			if (!$complete) {
				$can_publish = array_merge($can_publish, array_diff($can_publish_cond, array_keys($cond_data['published_by'])));
			}
		}//end for

		return array_unique($can_publish);


	}//end _whoCanPublishWorkflow()


	/**
	* Goes through the passed workflow array and sets what step we are up to
	*
	* @param array	&$workflow	the workflow we are working out the current step for
	*
	* @return void
	* @access private
	*/
	function _loadCurrentStep(&$workflow)
	{
		// run through and work out what step we are up to
		$workflow['current_step'] = Array();

		$current_step_found = FALSE;
		$step_array =& $workflow['steps'];

		while (!$current_step_found) {
			$current_step_found = TRUE;
			for (reset($step_array); NULL !== ($stepid = key($step_array)); next($step_array)) {
				$step_data =& $step_array[$stepid];

				// 'load' the current step

				$last_key = end(array_keys($workflow['current_step']));
				$workflow['current_step'][$last_key] = $stepid;

				if ($step_data['expired']) {
					if ($step_data['completed']) {

						// expired and complete means that it expired, but was completed by virtue of its escalation workflow being completed
						$current_step_found = FALSE;
						continue;
					} else {
						// we need to move to this asset's substeps if there are any, otherwise to the sibling.
						$step_array =& $step_data['escalation_steps'];

						// add an element to the current step array cos we're going deeper.
						$workflow['current_step'][] = $stepid;
						$current_step_found = FALSE;

						// make the new asset the step array and keep running
						continue(2);
					}
				}

				$current_step_found = TRUE;
				$completed_conds = 0;

				for (reset($step_data['conditions']);
						NULL !== ($pub = key($step_data['conditions'])); next($step_data['conditions'])) {
					$current_step_found = TRUE;
					$cond_data =& $step_data['conditions'][$pub];

					// safety code
					if (!isset($cond_data['complete'])) {
						$cond_data['complete'] = FALSE;
					}
					if (!isset($cond_data['published_by'])) {
						$cond_data['published_by'] = Array();
					}

					if (empty($cond_data['published_by'])) {
						// nobody has approved this, so it cant be finished
						if ($step_data['logic'] == 'all') {
							$current_step_found = TRUE;
							break(2);
						} else {
							continue;
						}
					}
					$complete = FALSE;

					if ($cond_data['complete']) {
						$current_step_found = FALSE;
						$complete = TRUE;
					} else {

						$current_step_found = TRUE;
						if ($cond_data['logic'] == 'all') {
							// lets work out what number 'ALL' represents
							$can_publish_cond = Array();
							$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($pub);
							if ($asset->id) {
								if (is_a($asset, 'user')) {
									$can_publish_cond[] = $asset->id;
								} else if (is_a($asset, 'user_group')) {
									$can_publish_cond = array_keys($GLOBALS['SQ_SYSTEM']->am->getChildren($asset->id, Array('user'), FALSE));
								}
							}
							$cond_string = 'if ('.count($cond_data['published_by']).
										   ' >= '.count($can_publish_cond).') { $complete = true; }';
						} else {
							$cond_string = 'if ('.count($cond_data['published_by']).
										   ' '.$cond_data['logic'].') { $complete = true; }';
						}
						eval($cond_string);
					}

					if ($complete) {
						// this condition has been completed
						$cond_data['complete'] = TRUE;
						$current_step_found = FALSE;
						$completed_conds++;
						if ($step_data['logic'] == 'all') continue;

						$step_completed = FALSE;
						$logic_string = 'if ('.$completed_conds.' '.$step_data['logic'].' ) { $step_completed = true; }';
						eval($logic_string);

						if ($step_completed) {
							// this step is completed so move to the next one
							break;
						} else {
							// step is not finished yet so move to the next condition
							$current_step_found = TRUE;
							continue;
						}
					}
				}//end for

				// is the current step complete? If not, we are up to this step and can return

				if ($step_data['logic'] == 'all' && $completed_conds < count($step_data['conditions'])) {
					$current_step_found = TRUE;
				}
				if ($current_step_found) break;
			}//end for


			// we've been through all the siblings at the current level, and they're all complete.
			$last_key = end(array_keys($workflow['current_step']));
			if ($workflow['current_step'][$last_key] == count($step_array) && $current_step_found == FALSE) {

				// if we're at the top level of workflow, we can't unescalate, we're cooked
				if (count($workflow['current_step']) == 1) {
					$workflow['current_step'] = Array();
					$current_step_found = TRUE;
					continue;
				}

				// get the index of the current step at this level. We should be at the bottom level, so take the last token from current_step.

				$completed_step_id = array_pop($workflow['current_step']);

				$step_array[$completed_step_id]['completed'] = time();


				// ideally we don't want to set complete and start times for steps in here, but we
				// need to indicate somehow that we've just checked out the escalation workflow and it's all done
				$step_array =& $this->getCurrentStepArray($workflow);
				$current_step_id = end($workflow['current_step']);
				$step_array[$current_step_id]['completed'] = time();

			}
		}//end while !current step found

	}//end _loadCurrentStep()


	/**
	* Changes the running workflows for an asset to indicate that a user has approved the asset
	*
	* @param int	$assetid	the ID of the asset to set the approval for
	* @param int	$publisher	the ID of the user who has approved
	*
	* @return boolean
	* @access public
	*/
	function recordPublish($assetid, $publisher)
	{
		$assetid = (int) $assetid;
		$asset   =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0160', E_USER_WARNING, $assetid);
			return FALSE;
		}

		// if there are no current workflows running, how can someone publish (you do the math)?
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (empty($running_schemas)) return FALSE;
		$schema_workflows = $this->getSchemaWorkflows($assetid);

		// we'll need these for later to check if any workflow has changed steps
		if (!$this->silentWorkflowParty($asset->id)) {
			$steps_before = $this->getWorkflowCurrentSteps($asset->id);
			$publishers_before = $this->whoCanPublish($asset->id);
		}

		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'UPDATE
					sq_ast_wflow
				SET
					wflow	= ?
				WHERE
						assetid		= ?
					AND	schemaid	= ?';

		$prepared = $db->prepare($sql);
		assert_valid_db_result($prepared);

		for (reset($schema_workflows); NULL !== ($schemaid = key($schema_workflows)); next($schema_workflows)) {
			if (!in_array($schemaid, $running_schemas)) continue;
			$workflow =& $schema_workflows[$schemaid];
			if ($workflow['complete'] == TRUE) continue;
			if ($this->_recordPublish($workflow, $publisher, $assetid)) {
				$new_workflow = serialize($workflow);

				$values = Array(
							$new_workflow,
							$assetid,
							$schemaid,
						  );

				$result = $db->execute($prepared, $values);

				assert_valid_db_result($result);

				// updated cached version of this workflow
				$this->_tmp['schema_workflows'][$assetid][$schemaid] = $workflow;
				if (isset($this->_tmp['schema_workflows'][$assetid]['all'][$schemaid])) {
					$this->_tmp['schema_workflows'][$assetid]['all'][$schemaid] = $workflow;
				}
			}
		}

		// send an internal message to let people know someone has approved
		$asset_type = $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name');
		$user       =& $GLOBALS['SQ_SYSTEM']->am->getAsset($GLOBALS['SQ_SYSTEM']->currentUserId());
		$ms         =& $GLOBALS['SQ_SYSTEM']->getMessagingService();

		$log = $ms->newMessage();
		$msg_reps = Array(
						'user_name'		=> $user->name,
						'type_code'		=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
						'asset_name'	=> $asset->name,
						'workflow_url'	=> current_url().$asset->getBackendHref('workflow', FALSE),
					);
		$log->replacements = $msg_reps;
		$log->type = 'asset.workflow.log.approve';
		$log->parameters['assetid'] = $asset->id;
		$log->parameters['version'] = substr($asset->version, 0, strrpos($asset->version, '.'));
		$ms->enqueueMessage($log);

		// send internal messages to everyone who could approve before to let them know that someone did
		if (!$this->silentWorkflowParty($asset->id)) {
			$msg = $ms->newMessage($publishers_before);
			$msg->type    = 'asset.workflow.announce.approve';
			$msg->parameters['assetid'] = $asset->id;
			$msg->replacements = $msg_reps;
			$ms->enqueueMessage($msg);
		}

		// now check if any workflows have progressed to the next step
		// and send messages to the new approvers if they have
		if (!$this->silentWorkflowParty($asset->id)) {
			$steps_after = $this->getWorkflowCurrentSteps($asset->id);
			foreach ($steps_after as $schemaid => $step) {
				// Are there actually no steps left?
				if (empty($step)) continue;

				if (!($step == $steps_before[$schemaid])) {
					$publishers = $this->whoCanPublish($asset->id, $schemaid);
					// send internal messages to everyone in the next step who can now publish the asset
					$msg = $ms->newMessage($publishers);

					$workflow =& $schema_workflows[$schemaid];
					$previous_step =& $this->getCurrentStep($workflow, $steps_before[$schemaid]);
					$previous_step_name =& $previous_step['step_name'];
					$current_step =& $this->getCurrentStep($workflow, $step);
					$current_step_name =& $current_step['step_name'];

					$msg_reps = Array(
									'user_name'				=> $user->name,
									'type_code'				=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
									'asset_name'			=> $asset->name,
									'previous_step_id'		=> implode('.', $steps_before[$schemaid]),
									'previous_step_name'	=> $previous_step_name,
									'current_step_id'		=> implode('.', $step),
									'current_step_name'		=> $current_step_name,
									'workflow_url'			=> current_url().$asset->getBackendHref('workflow', FALSE),
								);

					$asset_edt_fns = $asset->getEditFns();
					if (isset($asset_edt_fns->static_screens['preview'])) {
						$msg_reps['preview_url'] = current_url().$asset->getBackendHref('preview', FALSE);
					} else {
						$msg_reps['preview_url'] = current_url().$asset->getBackendHref('details', FALSE);
					}

					$msg->type    = 'asset.workflow.invitation.progress';
					$msg->parameters['assetid'] = $asset->id;
					$msg->replacements = $msg_reps;
					$ms->enqueueMessage($msg);
				}//end if step has advanced
			}//end foreach $steps_after
		}//end if not silent workflow party

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();
		return TRUE;

	}//end recordPublish()


	/**
	* Pretend this user has approved the workflow to see if the workflow process will be completed
	*
	* Use this to find out if the user is allowed to live edit.
	*
	* @param int	$assetid	the ID of the asset to set the approval for
	* @param int	$publisher	the ID of the user who we are testing approval for
	*
	* @return boolean
	* @access public
	*/
	function testPublish($assetid, $publisher)
	{
		$schema_workflows = $this->getSchemaWorkflows($assetid);
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (empty($running_schemas)) {
			// we dont actually have any running workflows, so lets pretend we do
			$schemas = $this->getSchemas($assetid, TRUE);
			foreach ($schemas as $schemaid) {
				$schema_workflows[$schemaid] = $this->generateWorkflowArray($assetid, $schemaid);
				$running_schemas[] = $schemaid;
			}
		}

		for (reset($schema_workflows); NULL !== ($schemaid = key($schema_workflows)); next($schema_workflows)) {
			if (!in_array($schemaid, $running_schemas)) continue;
			$workflow =& $schema_workflows[$schemaid];
			if ($workflow['complete']) continue;
			if (!$this->_recordPublish($workflow, $publisher, $assetid)) {
				return FALSE;
			}
			if (!$workflow['complete']) return FALSE;
		}

		return TRUE;

	}//end testPublish()


	/**
	* Changes the passed workflow to indicate that a user has approved the asset
	*
	* Returns TRUE if the publisher was able to publish and thus that the passed workflow
	* has actually changed - FALSE otherwise. This code is abstracted from RecordPublish so
	* it can be used by testPublish
	*
	* @param array	&$workflow		the workflow add approval to
	* @param int	$publisherid	the ID of the user who has approved
	* @param int	$assetid		the ID of the asset being published
	*
	* @return boolean
	* @access public
	*/
	function _recordPublish(&$workflow, $publisherid, $assetid)
	{
		$am =& $GLOBALS['SQ_SYSTEM']->am;
		$workflow_updated = FALSE;

		// safety code for blank workflows
		if (empty($workflow['steps'])) {
			$workflow_updated = TRUE;
			$workflow['steps'] = Array();
		} else {
			$step_data =& $this->getCurrentStep($workflow);
			for (reset($step_data['conditions']);
					NULL !== ($pub = key($step_data['conditions'])); next($step_data['conditions'])) {

				$cond_data =& $step_data['conditions'][$pub];
				// work out who can publish this condition
				$can_publish = Array();
				$publisher =& $GLOBALS['SQ_SYSTEM']->am->getAsset($pub);
				if ($publisher->id) {
					$asset_class = get_class($publisher);

					// Note that the order of IF statements is important, because roles are
					// a descendent of groups but should be treated differently
					if ($am->isTypeDecendant($asset_class, 'user')) {
						$can_publish[] = $publisher->id;
					} else if ($am->isTypeDecendant($asset_class, 'role')) {
						$roles = $GLOBALS['SQ_SYSTEM']->am->getRole($assetid, $publisher->id, NULL, FALSE, FALSE, TRUE);
						foreach ($roles as $roleid => $userids) {
							foreach ($userids as $userid) {
								if ($userid == '0') continue;
								$can_publish[] = $userid;
							}
						}
					} else if ($am->isTypeDecendant($asset_class, 'user_group')) {
						$can_publish = array_keys($GLOBALS['SQ_SYSTEM']->am->getChildren($publisher->id, Array('user'), FALSE, NULL, NULL, NULL, TRUE, NULL, NULL, FALSE));
					}
				}

				if (in_array($publisherid, $can_publish)) {
					if (!isset($cond_data['published_by'])) {
						$cond_data['published_by'] = Array();
					}
					// if the publisherid has not already published
					if (!isset($cond_data['published_by'][$publisherid])) {
						$cond_data['published_by'][$publisherid] = time();
						$workflow_updated = TRUE;
					}
				}
			}//end for

			if ($workflow_updated) {
				// load the current step into the workflow
				$this->_loadCurrentStep($workflow);

				// if the current step returns nothing, workflow is complete
				if ($workflow['current_step'] === Array()) {
					$workflow['complete'] = TRUE;
					// mark the last step as completed
					$num_steps = count($workflow['steps']);
					if ($num_steps > 0) {
						$workflow['steps'][$num_steps]['completed'] = time();
					}
				} else {
					$current_step =& $this->getCurrentStep($workflow);
					if (!$current_step['started']) {
						$current_step['started'] = time();
					}
					// if this is not the first step in this workflow,
					$last_key = end(array_keys($workflow['current_step']));
					if ($workflow['current_step'][$last_key] > 1) {
						$previous_step_address = $workflow['current_step'];
						$previous_step_address[$last_key]--;
						$previous_step =& $this->getCurrentStep($workflow, $previous_step_address);
						if (!$previous_step['completed']) {
							$previous_step['completed'] = time();
						}
					}
				}
			}
		}//end else

		return $workflow_updated;

	}//end _recordPublish()


	/**
	* Generate an array representing the workflow structure for a schema at this point in time
	*
	* The generated array is a snap shot of the schema at a point in time that can get written
	* to the database and used for publishing etc.
	*
	* @param int	$assetid	the ID of the asset to generate the file for
	* @param int	$schemaid	the ID of the schema
	*
	* @return boolean
	* @access public
	*/
	function generateWorkflowArray($assetid, $schemaid)
	{
		$assetid  = (int) $assetid;
		$schemaid = (int) $schemaid;

		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0155', E_USER_WARNING, $assetid);
			return FALSE;
		}

		$schema =& $GLOBALS['SQ_SYSTEM']->am->getAsset($schemaid);
		if (is_null($schema)) {
			trigger_localised_error('SYS0156', E_USER_WARNING, $schemaid);
			return FALSE;
		}

		if (!is_a($schema, 'workflow_schema')) {
			trigger_localised_error('SYS0154', E_USER_WARNING, $schema->name, $schemaid);
			return FALSE;
		}

		// check that the schema we are generating an array for is actually set
		$schemas = $this->getSchemas($assetid, TRUE);
		if (!in_array($schemaid, $schemas)) return Array();

		$edit_fns = $schema->getEditFns();
		return $edit_fns->generateWorkflowArray($schema);

	}//end generateWorkflowArray()


	/**
	* Starts workflow by writing out all workflow arrays to the workflow table for the passed assetID
	*
	* @param int		$assetid		the ID of the asset to start workflow for
	* @param boolean	$auto_approve	register that the current user has approed the workflow	once it has been started
	* @param object		$msg			an internal message to be sent instead of the default
	*
	* @return boolean
	* @access public
	*/
	function startWorkflow($assetid, $auto_approve=TRUE, $msg=NULL)
	{
		$assetid  = (int) $assetid;
		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0179', E_USER_WARNING, $assetid);
			return FALSE;
		}

		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$schemas = $this->getSchemas($assetid, TRUE, FALSE);

		if (empty($schemas)) return FALSE;

		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'UPDATE
					sq_ast_wflow
				SET
					wflow	= ?
				WHERE
						assetid		= ?
					AND	schemaid	= ?';

		$prepared = $db->prepare($sql);
		assert_valid_db_result($prepared);

		foreach ($schemas as $schemaid) {
			$workflow = $this->generateWorkflowArray($assetid, $schemaid);
			if (empty($workflow['steps'])) continue;
			$workflow = serialize($workflow);

			$values = Array(
						$workflow,
						$assetid,
						$schemaid,
					  );
			$result = $db->execute($prepared, $values);
			assert_valid_db_result($result);
		}
		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();

		$this->_tmp = Array();

		if ($auto_approve) {
			// if the user who has started this workflow is also able to
			// approve it as part of workflow, let their action to start workflow
			// signal their intention to approve it as well
			$publishers = $this->whoCanPublish($asset->id);
			$current_userid = $GLOBALS['SQ_SYSTEM']->currentUserId();
			if (in_array($current_userid, $publishers)) {
				if (!$this->recordPublish($asset->id, $current_userid)) {
					trigger_localised_error('SYS0078', E_USER_WARNING, $current_userid);
					// dont die here because they can try to approve again later, we just want to warn them
				}
			}
		}

		// send internal messages to everyone who can now publish the asset
		$ms   =& $GLOBALS['SQ_SYSTEM']->getMessagingService();
		$publishers = $this->whoCanPublish($asset->id);

		if (!$this->silentWorkflowParty($asset->id)) {
			// create a new internal message if we have not been supplied with one
			if (is_null($msg)) $msg = $ms->newMessage();
			// added the publishers to the list of people that are to be notified
			$msg->to = array_merge($msg->to, $publishers);

			// complete any missing internal message fields that have not been supplied
			if (empty($msg->replacements)) {
				$user =& $GLOBALS['SQ_SYSTEM']->am->getAsset($GLOBALS['SQ_SYSTEM']->currentUserId());
				$msg_reps = Array(
								'user_name'		=> $user->name,
								'type_code'		=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
								'asset_name'	=> $asset->name,
								'workflow_url'	=> current_url().$asset->getBackendHref('workflow', FALSE),
							);
				$asset_edt_fns = $asset->getEditFns();
				if (isset($asset_edt_fns->static_screens['preview'])) {
					$msg_reps['preview_url'] = current_url().$asset->getBackendHref('preview', FALSE);
				} else {
					$msg_reps['preview_url'] = current_url().$asset->getBackendHref('details', FALSE);
				}
				$msg->replacements = $msg_reps;
			}
			if (empty($msg->type)) {
				$msg->type = 'asset.workflow.invitation';
			}

			$msg->parameters['assetid'] = $asset->id;
			$ms->enqueueMessage($msg);
		}

		return TRUE;

	}//end startWorkflow()


	/**
	* Starts workflow by writing out all workflow arrays to the workflow table for the passed assetID
	*
	* @param int	$assetid	the ID of the asset to check workflow completness for
	*
	* @return boolean
	* @access public
	*/
	function isWorkflowComplete($assetid)
	{
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (empty($running_schemas)) return TRUE;
		$schema_workflows = $this->getSchemaWorkflows($assetid);

		foreach ($schema_workflows as $schemaid => $workflow) {
			if (!in_array($schemaid, $running_schemas)) continue;
			if (empty($workflow['steps'])) continue;
			if (!$workflow['complete']) return FALSE;
		}

		return TRUE;

	}//end isWorkflowComplete()


	/**
	* Starts workflow by writing out all workflow arrays to the workflow table for the passed assetID
	*
	* @param int	$assetid	the ID of the asset to check workflow completness for
	*
	* @return array
	* @access public
	*/
	function getWorkflowCurrentSteps($assetid)
	{
		$running_schemas = $this->getSchemas($assetid, TRUE, TRUE);
		if (empty($running_schemas)) return Array();
		$schema_workflows = $this->getSchemaWorkflows($assetid);

		$steps = Array();
		foreach ($schema_workflows as $schemaid => $workflow) {
			if (!in_array($schemaid, $running_schemas)) continue;
			if (empty($workflow['steps'])) continue;
			$steps[$schemaid] = $workflow['current_step'];

		}

		return $steps;

	}//end getWorkflowCurrentSteps()


	/**
	* Cancel the currently running workflows for the passed asset
	*
	* @param int	$assetid	the ID of the asset to cancel workflow for
	* @param object	$msg		an internal message to be sent instead of the default
	*
	* @return boolean
	* @access public
	*/
	function cancelWorkflow($assetid, $msg=NULL)
	{
		$assetid = (int) $assetid;
		$asset   =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0146', E_USER_WARNING, $assetid);
			return FALSE;
		}

		// we have to get the publishers before the workflow is cleared, because
		// this function depends on having a workflow running
		$publishers = $this->whoCanPublish($asset->id);

		if (!$this->_clearWorkflow($assetid)) return FALSE;

		// send internal messages to everyone who could approve before to let them know that someone cancelled
		if (!$this->silentWorkflowParty($asset->id)) {
			$ms =& $GLOBALS['SQ_SYSTEM']->getMessagingService();

			// create a new internal message if we have not been supplied with one
			if (is_null($msg)) $msg = $ms->newMessage();
			// added the publishers to the list of people that are to be notified
			$msg->to = array_merge($msg->to, $publishers);

			// complete any missing internal message fields that have not been supplied
			if (empty($msg->replacements)) {
				$user =& $GLOBALS['SQ_SYSTEM']->am->getAsset($GLOBALS['SQ_SYSTEM']->currentUserId());
				$msg_reps = Array(
								'user_name'		=> $user->name,
								'type_code'		=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
								'asset_name'	=> $asset->name,
								'workflow_url'	=> current_url().$asset->getBackendHref('workflow', FALSE),
							);
				$asset_edt_fns = $asset->getEditFns();
				if (isset($asset_edt_fns->static_screens['preview'])) {
					$msg_reps['preview_url'] = current_url().$asset->getBackendHref('preview', FALSE);
				} else {
					$msg_reps['preview_url'] = current_url().$asset->getBackendHref('details', FALSE);
				}
				$msg->replacements = $msg_reps;
			}
			if (empty($msg->type)) {
				$msg->type = 'asset.workflow.announce.reject';
			}

			$msg->parameters['assetid'] = $asset->id;
			$ms->enqueueMessage($msg);
		}//end if

		return TRUE;

	}//end cancelWorkflow()


	/**
	* Completes the workflow by clearing out all the running workflows from the DB
	*
	* @param int	$assetid	the ID of the asset to complete workflow for
	*
	* @return boolean
	* @access public
	*/
	function completeWorkflow($assetid)
	{
		$assetid = (int) $assetid;
		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0150', E_USER_WARNING, $assetid);
			return FALSE;
		}

		return $this->_clearWorkflow($assetid);

	}//end completeWorkflow()


	/**
	* Clears all generated workflow arrays from the workflow table for the passed assetID
	*
	* @param int	$assetid	the ID of the asset to clear workflow for
	*
	* @return boolean
	* @access public
	*/
	function _clearWorkflow($assetid)
	{
		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'UPDATE
					sq_ast_wflow
				SET
					wflow = NULL
				WHERE
					assetid	 = ?';

		$prepared = $db->prepare($sql);
		assert_valid_db_result($prepared);

		$values = Array($assetid);

		$result = $db->execute($prepared, $values);
		assert_valid_db_result($result);

		unset($this->_tmp['schemas'][$assetid]);
		unset($this->_tmp['schema_workflows'][$assetid]);

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();

		return TRUE;

	}//end _clearWorkflow()


	/**
	* Deletes any workflow entries that this asset has
	*
	* @param string	$assetid	the asset id
	*
	* @return boolean
	* @access public
	*/
	function purgeWorkflow($assetid)
	{
		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'DELETE FROM
					sq_ast_wflow
				WHERE
					assetid	= '.$db->quoteSmart($assetid);

		$result = $db->query($sql);
		assert_valid_db_result($result);

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();

		return TRUE;

	}//end purgeWorkflow()


	/**
	* Check if the passed assetid is a silent party in the worflow process
	*
	* For example, when pulling a standard page through workflow, the bodycopy
	* is a silent party because it cannot be shared and so has the same admins
	* as the standard page. However, any tables can be shared and so they are not
	* silent parties.
	*
	* @param int	$assetid	the ID of the asset to check
	*
	* @return boolean
	* @access public
	*/
	function silentWorkflowParty($assetid)
	{
		$asset =& $GLOBALS['SQ_SYSTEM']->am->getAsset((int) $assetid);
		if (is_null($asset)) return TRUE;
		$edit_fns = $asset->getEditFns();
		return !isset($edit_fns->static_screens['workflow']);

	}//end silentWorkflowParty()


	/**
	* Escalates workflow
	*
	* If there are escalation steps, move to them. If not, move to sibling.
	*
	* @param int	$assetid	the ID of the asset who's workflow is being escalated
	* @param int	$schemaid	The ID of the schema being escalated
	*
	* @return boolean
	* @access public
	*/
	function escalateWorkflow($assetid, $schemaid)
	{
		$assetid = (int) $assetid;
		$asset   =& $GLOBALS['SQ_SYSTEM']->am->getAsset($assetid);
		if (is_null($asset)) {
			trigger_localised_error('SYS0160', E_USER_WARNING, $assetid);
			return FALSE;
		}

		$ms =& $GLOBALS['SQ_SYSTEM']->getMessagingService();
		$schema_workflows = $this->getSchemaWorkflows($assetid);
		$workflow =& $schema_workflows[$schemaid];


		// mark the current step as escalated
		$current_step =& $this->getCurrentStep($workflow);

		// we'll need these for later to check if any workflow has changed steps
		$step_before = $current_step;
		$step_before_id = $workflow['current_step'];
		$publishers_before = $this->whoCanPublish($assetid);


		$current_step['expired'] = TRUE;

		// if there are no escalation steps for the current step, we can't escalate to substeps, so defer to the next step
		if (empty($current_step['escalation_steps'])) {
			$current_step['completed'] = time();
		}

		// load the current step into the workflow
		$this->_loadCurrentStep($workflow);



		if ($workflow['current_step'] == Array()) {
			// We can't complete workflow by escalating
			$hrefs = $GLOBALS['SQ_SYSTEM']->am->getAssetBackendHref(Array($assetid => 'workflow'), FALSE);
			$href = str_replace('./', '', current($hrefs));
			$root_urls = explode("\n", SQ_CONF_SYSTEM_ROOT_URLS);
			$url = 'http://'.current($root_urls).'/'.$href;
			$type = 'asset.workflow.stale';
			$admins = $GLOBALS['SQ_SYSTEM']->am->getPermission($assetid, SQ_PERMISSION_ADMIN, TRUE, FALSE, TRUE);

			$msg_reps = Array(
							'asset_name'	=> $asset->attr('name'),
							'assetid'		=> $assetid,
							'step_id'		=> implode('.', $step_before_id),
							'step_name'		=> $current_step['step_name'],
							'schema'		=> $workflow['schema_name'],
							'started_time'	=> easy_datetime($current_step['started']),
							'expiry_time'	=> easy_time_total($current_step['expiry_time']),
							'workflow_url'	=> $url,
						);
			$msg = $ms->newMessage($admins, $type, $msg_reps);
			$msg->send();

			return TRUE;
		}

		// we may have gone deeper in workflow. If so, mark the current step as started.,

		$current_step =& $this->getCurrentStep($workflow);
		if (!$current_step['started']) {
			$current_step['started'] = time();
		}


		$GLOBALS['SQ_SYSTEM']->changeDatabaseConnection('db2');
		$db =& $GLOBALS['SQ_SYSTEM']->db;
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		$sql = 'UPDATE
					sq_ast_wflow
				SET
					wflow	= ?
				WHERE
						assetid		= ?
					AND	schemaid	= ?';

		$prepared = $db->prepare($sql);
		assert_valid_db_result($prepared);
		$new_workflow = serialize($workflow);

		$values = Array(
					$new_workflow,
					$assetid,
					$schemaid,
				  );

		$result = $db->execute($prepared, $values);

		assert_valid_db_result($result);
		$this->_tmp['schema_workflows'][$assetid][$schemaid] = $workflow;
		if (isset($this->_tmp['schema_workflows'][$assetid]['all'][$schemaid])) {
			$this->_tmp['schema_workflows'][$assetid]['all'][$schemaid] = $workflow;
		}


		// send an internal message to let people know workflow has been escalated
		$asset_type = $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name');
		$user       =& $GLOBALS['SQ_SYSTEM']->am->getAsset($GLOBALS['SQ_SYSTEM']->currentUserId());


		$log = $ms->newMessage();

		$msg_reps = Array(
						'user_name'				=> $user->name,
						'type_code'				=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
						'asset_name'			=> $asset->name,
						'workflow_url'			=> current_url().$asset->getBackendHref('workflow', FALSE),
						'assetid'				=> $assetid,
						'previous_step_id'		=> implode('.', $step_before_id),
						'previous_step_name'	=> $step_before['step_name'],
						'current_step_id'		=> implode('.', $workflow['current_step']),
						'current_step_name'		=> $current_step['step_name'],
						'schema'				=> $workflow['schema_name'],
						'started_time'			=> easy_datetime($step_before['started']),
						'expiry_time'			=> easy_time_total($step_before['expiry_time']),
					);

		$log->replacements = $msg_reps;
		$log->type = 'asset.workflow.log.escalated';

		$log->parameters['assetid'] = $asset->id;
		$log->parameters['version'] = substr($asset->version, 0, strrpos($asset->version, '.'));
		$ms->enqueueMessage($log);


		// send internal messages to everyone who could approve before to let them know they have lost their chance

		if (!$this->silentWorkflowParty($asset->id)) {

			$msg = $ms->newMessage($publishers_before);
			$msg->type    = 'asset.workflow.announce.escalated';
			$msg->parameters['assetid'] = $asset->id;
			$msg->replacements = $msg_reps;
			$ms->enqueueMessage($msg);

			// send messages to the new approvers if they have

			$publishers = $this->whoCanPublish($asset->id, $schemaid);
			// send internal messages to everyone in the next step who can now publish the asset
			$msg = $ms->newMessage($publishers);

			$msg_reps = Array(
							'user_name'				=> $user->name,
							'type_code'				=> $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset->type(), 'name'),
							'asset_name'			=> $asset->name,
							'previous_step_id'		=> implode('.',$step_before_id),
							'previous_step_name'	=> $step_before['step_name'],
							'current_step_id'		=> implode('.',$workflow['current_step']),
							'current_step_name'		=> $current_step['step_name'],
							'workflow_url'			=> current_url().$asset->getBackendHref('workflow', FALSE),
						);

			$asset_edt_fns = $asset->getEditFns();
			if (isset($asset_edt_fns->static_screens['preview'])) {
				$msg_reps['preview_url'] = current_url().$asset->getBackendHref('preview', FALSE);
			} else {
				$msg_reps['preview_url'] = current_url().$asset->getBackendHref('details', FALSE);
			}

			$msg->type    = 'asset.workflow.invitation.progress';
			$msg->parameters['assetid'] = $asset->id;
			$msg->replacements = $msg_reps;
			$ms->enqueueMessage($msg);
		}//end if

		$ms->sendQueuedEmails();

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
		$GLOBALS['SQ_SYSTEM']->restoreDatabaseConnection();

	return TRUE;

	}//end escalateWorkflow()


	/**
	* Returns an array of workflow steps containing the current or specified step and it's siblings
	*
	* @param array	&$workflow		the workflow we are searching in
	* @param array	$current_step	the address of the desired step
	*
	* @return array
	* @access public
	*/
	function &getCurrentStepArray(&$workflow, $current_step=NULL)
	{
		// go through workflow and return the current and sibling steps based on the current step
		if ($current_step == NULL) {
			$current_step = $workflow['current_step'];
		}

		array_pop($current_step);
		$steps =& $workflow['steps'];
		foreach ($current_step as $step_id) {
			$steps =& $steps[$step_id]['escalation_steps'];
		}
		return $steps;

	}//end getCurrentStepArray()


	/**
	* Returns a reference to the current or specified step
	*
	* @param array	&$workflow		the workflow we are searching in
	* @param array	$current_step	the address of the desired step
	*
	* @return array
	* @access public
	*/
	function &getCurrentStep(&$workflow, $current_step=NULL)
	{
		if ($current_step == NULL) {
			$current_step = $workflow['current_step'];
		}
		$steps =& $this->getCurrentStepArray($workflow, $current_step);

		return $steps[end($current_step)];

	}//end getCurrentStep()


}//end class

?>
