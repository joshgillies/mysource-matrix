<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Open Source Licence                                      |
* +--------------------------------------------------------------------+
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +--------------------------------------------------------------------+
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +--------------------------------------------------------------------+
*
* $Id: linking.inc,v 1.14.2.1 2006/03/21 23:41:29 lwright Exp $
*
*/

require_once SQ_LIB_PATH.'/html_form/html_form.inc';

/**
* Linking Static Screen Functions
*
* @author  Greg Sherwood <gsherwood@squiz.net>
* @version $Revision: 1.14.2.1 $
* @package MySource_Matrix
*/


/**
* Paints the interface for viewing links to/from this asset
*
* @param object	Asset					$owner		the asset whose interface we are painting
* @param object	Backend_Outputter		$o			the outputter class
* @param object	Asset_Edit_Interface	&$ei		the edit interface
* @param boolean						$allow_edit	allow editing of link types if user has access
*
* @return boolean
* @access public
*/
function paintLinking(&$owner, &$o, &$ei, $allow_edit=true)
{
	// If we are allowed to edit, we check the write effective access, minus live edit access
	// We are ignoring live edit access because changes to links are not reliant on
	// status of the asset (because the are not safe edited)
	$created = false;

	$write_access = ($allow_edit) ? $owner->writeAccess('links') :  false;

	// prefix for all the form vars
	$prefix = $owner->getPrefix();

	require_once SQ_INCLUDE_PATH.'/general_occasional.inc';
	$o->openSection(translate('current_linking'));
	$o->openField('');
	echo '<i>'.translate('link_types_note').'</i><br/><br/>';

	$db = &$GLOBALS['SQ_SYSTEM']->db;
	$assetids = Array();
	$asset_links = $GLOBALS['SQ_SYSTEM']->am->getLinks($owner->id, SQ_SC_LINK_ALL, '', true, 'minor');
	$editable_link_types = Array(
							SQ_LINK_TYPE_1	=> link_type_name(SQ_LINK_TYPE_1),
							SQ_LINK_TYPE_2	=> link_type_name(SQ_LINK_TYPE_2),
						   );

	foreach ($asset_links as $link) $assetids[$link['majorid']] = Array();

	if (empty($assetids)) {
		$result = Array();
	} else {
		$result = Array();

		$assetid_keys = array_keys($assetids);

		// Chunk Norris this query because the IN part will bomb with >1000
		// assets on Oracle
		foreach (array_chunk($assetid_keys, 500) as $assetids_chunk) {
			$sql = 'SELECT ct.treeid as our_treeid, cl.minorid, pt.treeid as parent_treeid, a.name, a.assetid
					FROM '.SQ_TABLE_RUNNING_PREFIX.'ast_lnk cl
							INNER JOIN '.SQ_TABLE_RUNNING_PREFIX.'ast_lnk_tree ct ON cl.linkid = ct.linkid,
						 '.SQ_TABLE_RUNNING_PREFIX.'ast_lnk pl
							INNER JOIN '.SQ_TABLE_RUNNING_PREFIX.'ast_lnk_tree pt ON pl.linkid = pt.linkid
							INNER JOIN '.SQ_TABLE_RUNNING_PREFIX.'ast a ON a.assetid = pl.minorid
					';
			$where = 'cl.minorid IN ('.implode(', ', $assetids_chunk).')
					  AND ct.treeid LIKE pt.treeid || '.$db->quote('%').'
					  AND pt.treeid <= ct.treeid';
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'cl');
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'ct');
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'pl');
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'pt');
			$where = $GLOBALS['SQ_SYSTEM']->constructRollbackWhereClause($where, 'a');

			$sql .= $where.' ORDER BY cl.linkid, ct.treeid, pt.treeid';

			$chunk_result = $db->getAssoc($sql, false, Array(), DB_FETCHMODE_ASSOC, true);

			assert_valid_db_result($chunk_result);
			$result += $chunk_result;
		}
	}

	foreach ($asset_links as $link_data) $link_info[$link_data['majorid']][] = $link_data;

	$output_lineages = Array();
	$editing_linkids = Array();
	foreach ($result as $treeid => $link_tree) {

		// work out some values we are going to need
		$parent_data = $link_tree[count($link_tree) -1];
		$majorid = $parent_data['assetid'];

		foreach ($link_info[$majorid] as $link_data) {

			$link_type = $link_data['link_type'];
			$linkid = $link_data['linkid'];

			// work out if the user can change the link types
			// the arg $allow_edit must be set to TRUE to try the write access test
			$can_edit = ($write_access && in_array($link_type, array_keys($editable_link_types)) && !in_array($linkid, $editing_linkids));

			$asset_lineage = '';
			foreach ($link_tree as $tree_data) {
				if ($tree_data['assetid'] == $majorid) continue;
				$asset_lineage .= $tree_data['name'].' &gt; ';
			}
			$asset_lineage .= '<b>'.$parent_data['name'].'</b>';
			if (isset($output_lineages[$asset_lineage]) && !$can_edit) continue;

			ob_start();
				?>
				<tr>
					<td class="sq-backend-table-cell" style="text-align: center;">
						<?php echo $linkid; ?>
					</td>
					<td class="sq-backend-table-cell" style="text-align: center;">
						<?php
						if (!$can_edit) {
							echo link_type_name($link_type);
						} else {
							combo_box($prefix.'_link_type['.$linkid.']', $editable_link_types, false, $link_type);
							$editing_linkids[] = $linkid;
						}
						?>
					</td>
					<td class="sq-backend-table-cell"><?php echo $asset_lineage; ?></td>
				</tr>
				<?php
				$output_lineages[] = ob_get_contents();
			ob_end_clean();
		}

	}//end foreach result

	if (!count($output_lineages)) {
		echo 'None';
	} else {
		?>
		<table class="sq-backend-table">
			<tr>
				<td class="sq-backend-table-header" style="text-align: center; white-space: nowrap;"><?php echo translate('link_id'); ?></td>
				<td class="sq-backend-table-header" style="text-align: center;"><?php echo translate('link_type'); ?></td>
				<td class="sq-backend-table-header" width="100%"><?php echo translate('lineage'); ?></td>
			</tr>
			<?php foreach ($output_lineages as $null => $lineage_data) echo $lineage_data; ?>
		</table>
		<?php
	}

	$o->closeSection();

	$GLOBALS['SQ_SYSTEM']->am->includeAsset('cron_job_future_lineage');
	$fl_jobs = &Cron_Job_Future_Lineage::getActiveJobs($owner);

	if (!empty($fl_jobs) || $write_access) {
		$created = true;
		$o->openSection(translate('future_linking'));
			if (!empty($fl_jobs)) {
				$o->openField('', 'new_line');
					?>
					<table class="sq-backend-table">
						<tr>
							<td class="sq-backend-table-header">
								<?php echo translate('action'); ?>
							</td>
							<td class="sq-backend-table-header">
								<?php echo translate('when'); ?>
							</td>
							<?php
							if ($write_access) {
								$created = true;
								?>
								<td class="sq-backend-table-header" style="text-align: center;"><?php echo translate('delete_question'); ?></td>
								<?php
							}
							?>
						</tr>
						<?php
						for ($i = 0; $i < count($fl_jobs); $i++) {
							?>
							<tr>
								<td class="sq-backend-table-cell">
									<?php echo nl2br($fl_jobs[$i]->readableDescription()); ?>
								</td>
								<td class="sq-backend-table-cell">
									<?php echo $fl_jobs[$i]->readableWhen(); ?>
								</td>
								<?php
								if ($write_access) {
									$created = true;
									?>
									<td class="sq-backend-table-cell" style="text-align: center;">
										<?php
										if ($fl_jobs[$i]->canDelete()) {
											check_box($prefix.'_remove_fl[]', $fl_jobs[$i]->id);
										} else {
											echo '&nbsp;';
										}
										?>
									</td>
									<?php
								}
								?>
							</tr>
							<?php
						}//end for
						?>
					</table>
					<br/>
					<?php
				$o->closeField();
			}//end if future lineage jobs

			if ($write_access) {
				$created = true;
				$fl = new Cron_Job_Future_Lineage();
				$fl->setAssetInLink($owner, 'minor');
				$edit_fns = $fl->getEditFns();
				$edit_fns->paintInLineBackend($fl, $o, $prefix.'_new_fl');
			}

		$o->closeSection();

	}//end if future lineage jobs or write access

	return $created;

}//end paintLinking()


/**
* Processes the interface for viewing links to/from this asset
*
* @param object	Asset					$owner		the asset whose interface we are painting
* @param object	Backend_Outputter		$o			the outputter class
* @param object	Asset_Edit_Interface	&$ei		the edit interface
*
* @return boolean
* @access public
*/
function processLinking(&$owner, &$o, &$ei)
{
	// if we dont have admin access, piss off
	if ($owner->id && !$owner->writeAccess('')) {
		$GLOBALS['SQ_SYSTEM']->paintLogin(translate('login'), translate('cannot_access_asset', $owner->name));
		exit();
	}

	// if we dont have effective write access, dont process anything
	if (!$owner->writeAccess('links')) return false;

	// prefix for all the form vars
	$prefix = $owner->getPrefix();

	$done_something = false;
	$asset_links = $GLOBALS['SQ_SYSTEM']->am->getLinks($owner->id, SQ_SC_LINK_ALL, '', true, 'minor');

	foreach ($asset_links as $link) {
		if (!isset($_POST[$prefix.'_link_type'][$link['linkid']])) continue;
		$new_type = $_POST[$prefix.'_link_type'][$link['linkid']];
		if ($link['link_type'] == $new_type) continue;
		if (!$GLOBALS['SQ_SYSTEM']->am->updateLink($link['linkid'], $new_type)) continue;
		$done_something = true;
	}

	$cron_mgr = &$GLOBALS['SQ_SYSTEM']->am->getSystemAsset('cron_manager');
	if (!is_null($cron_mgr)) {

		$GLOBALS['SQ_SYSTEM']->am->includeAsset('cron_job_future_lineage');

		if (!empty($_POST[$prefix.'_remove_fl'])) {
			$fl_jobs = &Cron_Job_Future_Lineage::getActiveJobs($owner);
			if (!empty($fl_jobs)) {

				if ($GLOBALS['SQ_SYSTEM']->am->acquireLock($cron_mgr->id, 'links')) {
					for ($i = 0; $i < count($fl_jobs); $i++) {
						if (in_array($fl_jobs[$i]->id, $_POST[$prefix.'_remove_fl'])) {
							if ($cron_mgr->removeJob($fl_jobs[$i])) {
								$is_updated = true;
							}
						}
					}

					$GLOBALS['SQ_SYSTEM']->am->releaseLock($cron_mgr->id, 'links');

				} else {
					trigger_localised_error('SYS0232', E_USER_NOTICE);
				}

			}// end if
		}// end if

		$fl = new Cron_Job_Future_Lineage();
		$edit_fns = $fl->getEditFns();
		if ($fl->setAssetInLink($owner, 'minor') && $edit_fns->processInLineBackend($fl, $o, $prefix.'_new_fl')) {
			$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');
			if ($cron_mgr->addJob($fl, $GLOBALS['SQ_SYSTEM']->user)) {
				$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');
				$done_something = true;
			} else {
				$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
			}
		}

	}// end if

	return $done_something;

}//end processLinking()


?>
