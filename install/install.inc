<?php
/**
* +--------------------------------------------------------------------+
* | Squiz.net Open Source Licence                                      |
* +--------------------------------------------------------------------+
* | Copyright (c), 2003 Squiz Pty Ltd (ABN 77 084 670 600).            |
* +--------------------------------------------------------------------+
* | This source file may be used subject to, and only in accordance    |
* | with, the Squiz Open Source Licence Agreement found at             |
* | http://www.squiz.net/licence.                                      |
* | Make sure you have read and accept the terms of that licence,      |
* | including its limitations of liability and disclaimers, before     |
* | using this software in any way. Your use of this software is       |
* | deemed to constitute agreement to be bound by that licence. If you |
* | modify, adapt or enhance this software, you agree to assign your   |
* | intellectual property rights in the modification, adaptation and   |
* | enhancement to Squiz Pty Ltd for use and distribution under that   |
* | licence.                                                           |
* +--------------------------------------------------------------------+
*
* $Id: install.inc,v 1.51.2.5 2005/10/26 04:03:38 lwright Exp $
*
*/

/**
* Install functions
*
* Purpose
* Functions used to install and upgrade the system
*
* @version $Revision: 1.51.2.5 $
* @package MySource_Matrix
* @subpackage install
*/


/**
* Regenerate all the configs used by Matrix
*
* @return boolean	indicating success or not of all configs saved
* @access public
*/
function regenerate_configs()
{
	// Re-generate the System Config to make sure that we get any new defines that may have been issued
	require_once SQ_INCLUDE_PATH.'/system_config.inc';
	$cfg = new System_Config();
	if (!$cfg->save(Array(), false)) return false;

	// Re-generate the External Tools Config to make sure that we get any new defines that may have been issued
	require_once SQ_INCLUDE_PATH.'/external_tools_config.inc';
	$cfg = new External_Tools_Config();
	if (!$cfg->save(Array(), false)) return false;

	// Re-generate the Server Config to make sure that we get any new defines that may have been issued
	require_once SQ_SYSTEM_ROOT.'/core/server/squiz_server_config.inc';
	$squiz_server_cfg = new Squiz_Server_Config();
	if (!$squiz_server_cfg->save(Array(), false)) {
		return false;
	}

	// Re-generate the HIPO Config to make sure that we get any new defines that may have been issued
	require_once SQ_SYSTEM_ROOT.'/core/hipo/hipo_config.inc';
	$hipo_cfg = new HIPO_Config();
	if (!$hipo_cfg->save(Array(), false)) return false;

	// Re-generate the Messaging Service Config to make sure that we get any new defines that may have been issued
	require_once SQ_SYSTEM_ROOT.'/core/include/messaging_service_config.inc';
	$ms_cfg = new Messaging_Service_Config();
	if (!$ms_cfg->save(Array(), false)) return false;

	// Re-generate the Password Rules Config to make sure that we get any new defines that may have been issued
	require_once SQ_SYSTEM_ROOT.'/core/include/password_rules_config.inc';
	$ms_cfg = new Password_Rules_Config();
	if (!$ms_cfg->save(Array(), false)) return false;

	return true;

}//end regenerate_configs()


/**
* Uninstall any assets that no longer have a .inc file
*
* @return boolean
* @access public
*/
function uninstall_asset_types()
{
	$db = &$GLOBALS['SQ_SYSTEM']->db;

	// always contains the full list of asset type_codes currently registered in the database
	$all_asset_types = $GLOBALS['SQ_SYSTEM']->am->getTypeList();

	// contains full list (yes we are getting this twice), but will be diff'd with
	// $package_asset_types leaving what type_codes can be safely deleted
	$asset_types = $GLOBALS['SQ_SYSTEM']->am->getTypeList();

	// type_codes of assets which are being claimed by a package
	$package_asset_types = Array();

	// find which packages are installed
	$packages_installed = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	if (!empty($packages_installed)) {
		foreach ($packages_installed as $package_array) {
			$package = $package_array['code_name'];

			// core package is something else
			if ($package == '__core__') {
				require_once SQ_CORE_PACKAGE_PATH.'/package_manager_core.inc';
				$pm = new Package_Manager_Core();
				$package_asset_types = array_merge($package_asset_types, array_keys($pm->assets));
			} else {
				// only process a package if the PM file exists for it, because we need it
				$package_path = SQ_PACKAGES_PATH.'/'.$package.'/package_manager_'.$package.'.inc';
				if (file_exists($package_path)) {
					require_once $package_path;
					$class = 'package_manager_'.$package;
					$pm = new $class();
					$package_asset_types = array_merge($package_asset_types, array_keys($pm->assets));
				}
			}
		}
	}

	// What's left after the diff are assets which no package thinks it owns, and can
	// safely be deleted
	$asset_types = array_diff($asset_types, $package_asset_types);

	// Asset types are deleted when no package manager thinks they have the asset type.
	// They think they have the asset type when the asset.xml says so
	if (!empty($asset_types)) {
		$errors = false;

		// check those asset types that are still going to be there after uninstall
		// to see whether it depended on something that is being deleted... if it is then
		// we have massive problems and should bail
		foreach (array_diff($all_asset_types,$asset_types) as $asset_type) {
			$asc = $GLOBALS['SQ_SYSTEM']->am->getTypeAncestors($asset_type);
			$deleted_parents = array_intersect($asset_types, $asc);

			// are our parents going to be binned?
			if (count($deleted_parents) > 0) {
				trigger_error('One or more of the parents for the asset type \''.$asset_type.'\' no longer exists in the system. The system may be broken until you restore the necessary files of the parent asset type to their proper location.'."\n".'\''.$asset_type.'\' depends on: '.implode(', ', $deleted_parents), E_USER_WARNING);
				$errors = true;
			}
		}

		// failed dependency tests => we're stuffed; bail
		if ($errors) {
			trigger_error('Asset hierarchy would be corrupted, uninstall not committed', E_USER_WARNING);
			exit(1);
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		// now actually delete the types
		foreach ($asset_types as $asset_type) {
			// delete the types
			$sql = 'DELETE FROM sq_ast_typ WHERE type_code = '.$db->quote($asset_type);

			$result = $db->query($sql);
			assert_valid_db_result($result);

			// remove the inherited types
			$sql = 'DELETE FROM sq_ast_typ_inhd
					WHERE type_code = '.$db->quote($asset_type).'
					  OR inhd_type_code = '.$db->quote($asset_type);

			$result = $db->query($sql);
			assert_valid_db_result($result);

			// remove the attributes
			$sql = 'DELETE FROM sq_ast_attr WHERE type_code = '.$db->quote($asset_type);

			$SQ_PACKAGES_PATH = $db->query($sql);
			assert_valid_db_result($SQ_PACKAGES_PATH);
		}

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');

		// report if we did uninstall some asset types
		if (!empty($asset_types)) {
			$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
			$msg_reps = Array(
							'type_code_list'	=> implode("\n", $asset_types),
						);
			$message = $ms->newMessage(Array(), 'install.asset_type.uninstall', $msg_reps);
			$message->send();
		}

	}//end if asset types not empty

	// clear the type cache
	@unlink(SQ_DATA_PATH.'/private/db/asset_types.inc');

	return true;

}//end uninstall_asset_types()


/**
* Uninstall any packages that don't have a package manager defined for them
*
* @return boolean
* @access public
*/
function uninstall_packages()
{
	$db = &$GLOBALS['SQ_SYSTEM']->db;

	// If the package manager doesn't exist for a package, it does not exist.
	// Assumption: packages live in the packages directory (Core never gets uninstalled).
	$packages_installed = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	if (!empty($packages_installed)) {
		$GLOBALS['SQ_SYSTEM']->doTransaction('BEGIN');

		foreach ($packages_installed as $package_array) {
			$package = $package_array['code_name'];

			// never delete the core package!
			if ($package == '__core__') continue;

			// package manager should exist for the package to exist
			$dir = 'packages/'.$package;
			$exists = file_exists(SQ_SYSTEM_ROOT.'/'.$dir.'/package_manager_'.$package.'.inc');

			if (!$exists) {
				// folder or the package manager does not exist, safe to delete
				$sql = 'DELETE FROM sq_pkg WHERE code_name = '.$db->quote($package);
				$result = $db->query($sql);
				assert_valid_db_result($result);

				// remove its asset map file from the data directory
				if (!unlink(SQ_DATA_PATH.'/private/asset_map/'.$package.'.xml')) {
					trigger_error('Could not delete the asset map file for "'.$package.'"', E_USER_WARNING);
					$GLOBALS['SQ_SYSTEM']->doTransaction('ROLLBACK');
					exit(1);
				}

				$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
				$message_body = 'Uninstalled '.$package;
				$msg_reps = Array(
								'package'	=> $package,
							);
				$message = $ms->newMessage(Array(), 'install.package.uninstall', $msg_reps);
				$message->send();

			}//end if exists

		}//end foreach installed package

		$GLOBALS['SQ_SYSTEM']->doTransaction('COMMIT');

	}//end if installed packages not empty

	return true;

}//end uninstall_packages()


/**
* Install core assets
*
* @param Array $packageList 		Lists what packages are going to be installed
*									and what assets in those packages.
* @return boolean
* @access public
*/
function install_core($package_list=Array())
{
	// If there's some packages defined in the array, make sure the Core
	// is one of them, otherwise break out.

	$assets = Array();

	if (count($package_list) > 0) {
		if (!isset($package_list['core'])) {
			return true;
		} else {
			$assets = $package_list['core'];
			// If it wasn't an array at the core index, just make it empty
			if (!is_array($assets)) $assets = Array();
		}
	}
	require_once SQ_CORE_PACKAGE_PATH.'/package_manager_core.inc';
	$pm = new Package_Manager_Core();
	$result = $pm->updatePackageDetails($assets);

	$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
	$msg_reps = Array(
					'package'	=> 'Core',
				);
	$message = $ms->newMessage(Array(), 'install.package.'.($result ? 'success' : 'fail'), $msg_reps);
	$message->send();

	if (!$result) exit(1);

	$result = $pm->installSystemAssets();

	// 0 (zero) indicates success, but no system assets were created - suppress in this case
	if ($result != 0) {
		$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
		$msg_reps = Array(
						'package'		=> 'Core',
						'num_assets'	=> $result,
					);
		$message = $ms->newMessage(Array(), 'install.system_assets.'.($result != -1 ? 'success' : 'fail'), $msg_reps);
		$message->send();

	}
	if ($result == -1) exit(1);

	// set the current user object to the root user so we can finish
	// the install process without permission denied errors
	$root_user = &$GLOBALS['SQ_SYSTEM']->am->getSystemAsset('root_user');
	$GLOBALS['SQ_SYSTEM']->setCurrentUser($root_user);

	return true;

}//end install_core()


/**
* Returns the entire list of packages that exist in the package directory
*
* @return array() the packages
* @access public
*/
function get_package_list()
{
	$packages = Array();
	$d = dir(SQ_PACKAGES_PATH);

	while (false !== ($entry = $d->read())) {
		if ($entry == '.' || $entry == '..') {
			continue;
		}
		// if this is a directory, process it
		if ($entry != 'CVS' && is_dir(SQ_PACKAGES_PATH.'/'.$entry)) {
			$packages[] = $entry;
		}
	}
	$d->close();

	return $packages;

}//end get_package_list()


/**
* Install all the packages into the system. Uses the $packages(Assets) arrays
* if defined to determine which assets to install. If a $package is defined,
* then it checks to see if the list of assets is defined for that package. If
* not, will install ALL assets.
*
* @param Array $package_assets	An array of assets inside packages to install.
*								Requires that the package name be defined in
*								the $packages array.
								Array('package_name' => Array('assetname'),)
* @return boolean
* @access public
*/
function install_packages($package_assets=Array())
{
	// right now that we have sorted all that out we can install the packages
	$d = dir(SQ_PACKAGES_PATH);

	$deferred_packages = Array();

	// Do we only install named packages?
	$limit_packages = count($package_assets);
	$packages = get_package_list();

	foreach ($packages as $package) {
		$assets = Array();
		if ($limit_packages) {
			if (!isset($package_assets[$package])) {
				echo "\nSkipping package $package \n";
				continue;
			}
			$assets = $package_assets[$package];
			// If it wasn't an array at the core index, just quit.
			if (!is_array($assets)) $assets = Array();
		}

		$result = install_package($package, $assets);
		if (is_array($result)) {
			$deferred_packages[$package] = $result;
		}
	}

	return count($deferred_packages) ? $deferred_packages : true;

}//end install_packages()


/**
* Installs a single package into the system.
*
* @param Array $package_assets	An array of asset types to install for this
*								package.
* @return mixed					void on success, otherwise an array of type_codes
* 								of assets that couldn't be installed yet.
* @access public
*/
function install_package($package, $package_assets=Array())
{
	require_once SQ_PACKAGES_PATH.'/'.$package.'/package_manager_'.$package.'.inc';
	require_once SQ_LIB_PATH.'/db_install/db_install.inc';
	$class = 'package_manager_'.$package;
	$pm = new $class();
	$result = $pm->updatePackageDetails($package_assets);

	$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();

	if (is_array($result)) {
		$msg_reps = Array(
						'package'	=> $package,
					);
		$message = $ms->newMessage(Array(), 'install.package.deferred', $msg_reps);
		$message->send();
		return $result;
	}

	$message_body = strtoupper($package).' PACKAGE '.(($result) ? 'DONE SUCCESSFULLY' : 'FAILED');
	$msg_reps = Array(
					'package'	=> $package,
				);
	$message = $ms->newMessage(Array(), 'install.package.'.($result ? 'success' : 'fail'), $msg_reps);
	$message->send();

	if (!$result) exit(1);
	$result = $pm->installSystemAssets();
	if ($result != 0) {	// 0 indicates success, but no system assets were created - suppress in this case
		$msg_reps = Array(
						'package'		=> $package,
						'num_assets'	=> $result,
					);
		$message_body = strtoupper($package).' SYSTEM ASSET CREATION '.(($result == -1) ? 'FAILED' : (': '.$result.' NEW ASSETS CREATED'));
		$message = $ms->newMessage(Array(), 'install.system_assets.'.($result ? 'success' : 'fail'), $msg_reps);
		$message->send();
	}

	if ($result == -1) exit(1);
	unset($pm);

	return true;

}//end install_package()


/**
* Try to install a list of deferred packages recursively until the list is the same as the start
*
* @param array $packages 	the array of packages to attempt to install
* @return mixed 			an array of any failed installed packages, or true if it all worked okay
* @access public
*/
function install_deferred($packages)
{
	$deferred = install_packages($packages);

	if ($deferred === true) return true;

	// if the arrays are identical, return the array
	if ($deferred == $packages) return $deferred;

	// the list should be smaller now...
	return install_deferred($deferred);

}//end install_deferred()


/**
* Install authentication types
*
* @return boolean
* @access public
*/
function install_authentication_types()
{
	// get all the authentication types that are currently installed
	$auth_types = $GLOBALS['SQ_SYSTEM']->am->getTypeDescendants('authentication');

	// get installed authentication systems
	$auth_folder = &$GLOBALS['SQ_SYSTEM']->am->getSystemAsset('authentication_folder');
	$links = $GLOBALS['SQ_SYSTEM']->am->getLinks($auth_folder->id, SQ_LINK_TYPE_1, 'authentication', false);
	$installed_auth_types = Array();
	foreach ($links as $link_data) {
		$installed_auth_types[] = $link_data['minor_type_code'];
	}

	// install all systems that are not currently installed
	$folder_link = Array(
					'asset'			=> &$auth_folder,
					'link_type'		=> SQ_LINK_TYPE_1,
					'is_exclusive'	=> 1,
				   );
	foreach ($auth_types as $type_code) {
		if (in_array($type_code, $installed_auth_types)) {
			continue;
		}
		$GLOBALS['SQ_SYSTEM']->am->includeAsset($type_code);
		$auth = new $type_code();

		if (!$auth->create($folder_link)) {
			trigger_error('AUTHENTICATION TYPE "'.strtoupper($type_code).'" NOT CREATED', E_USER_WARNING);
		} else {
			$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
			$msg_reps = Array(
							'auth_type_name'	=> strtoupper($type_code),
							'assetid'			=> $auth->id,
						);
			$message = $ms->newMessage(Array(), 'install.authentication', $msg_reps);
			$message->send();

		}
	}

	return true;

}//end install_authentication_types()


/**
* Generate the global preferences list
*
* @return boolean
* @access public
*/
function generate_global_preferences()
{
	// we need to install any event listeners here, now that we have installed all the asset types.
	$packages = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	$preferences = Array();
	if (is_file(SQ_DATA_PATH.'/private/conf/preferences.inc')) {
		include SQ_DATA_PATH.'/private/conf/preferences.inc';
	}

	foreach ($packages as $package) {
		// slight change for the core package
		if ($package['code_name'] == '__core__') {
			require_once SQ_CORE_PACKAGE_PATH.'/package_manager_core.inc';
			$class = 'package_manager_core';
		} else {
			require_once SQ_PACKAGES_PATH.'/'.$package['code_name'].'/package_manager_'.$package['code_name'].'.inc';
			$class = 'package_manager_'.$package['code_name'];
		}

		$pm = new $class();
		$pm->installUserPreferences($preferences);
		unset($pm);
	}
	$str = '<'.'?php $preferences = '.var_export($preferences, true).'; ?'.'>';
	if (!string_to_file($str, SQ_DATA_PATH.'/private/conf/preferences.inc')) {
		return false;
	}

	$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
	$message = $ms->newMessage(Array(), 'install.prefs', Array());
	$message->send();

	return true;

}//end generate_global_preferences()


/**
* Creates a cached file of the asset types and their information
*
* @access public
* @return void
*/
function cache_asset_types()
{
	$asset_types = $GLOBALS['SQ_SYSTEM']->am->getAssetTypes();

	$output = '<'.'?php'."\n".' $asset_types = ';
	$output .= var_export($asset_types, true);
	$output .= "\n?".'>';

	if (!string_to_file($output, SQ_DATA_PATH.'/private/db/asset_types.inc')) {
		trigger_error('Could not cache the asset types', E_USER_ERROR);
	}

	pre_echo('ASSET TYPES CACHED');

}//end cache_asset_types()


/**
* Install event listeners
*
* @return boolean
* @access public
*/
function install_event_listeners()
{
	// we need to install any event listeners here, now that we have installed all the asset types
	$packages = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	$em = &$GLOBALS['SQ_SYSTEM']->getEventManager();
	$em->writeStaticEventsCacheFile();

	$ms = &$GLOBALS['SQ_SYSTEM']->getMessagingService();
	$message = $ms->newMessage(Array(), 'install.event_listeners', Array());
	$message->send();

	return true;

}//end install_event_listeners()


/**
* Format an array of packages => Array(type_codes) for display
*
* @param array $array the array of deferred types to format
*
* @return string
* @access public
*/
function format_deferred_packages($packages)
{
	$out = '';
	foreach ($packages as $package => $types) {
		$out .= "\n".$package.":\n";
		foreach ($types as $type) {
			$out .= "\t".$type."\n";
		}
	}

	return $out;

}//end format_deferred_packages()


function find_asset_type_dirs($asset_type)
{
	if ($asset_type != 'asset') {
		$asset_dir = SQ_SYSTEM_ROOT.'/'.$GLOBALS['SQ_SYSTEM']->am->getTypeInfo($asset_type, 'dir');

		$asset_dirs = Array($asset_dir);
		$parent_type = $asset_type;
		while (($parent_type = $GLOBALS['SQ_SYSTEM']->am->getTypeInfo($parent_type, 'parent_type')) != 'asset') {
			$asset_dirs[] = SQ_SYSTEM_ROOT.'/'.$GLOBALS['SQ_SYSTEM']->am->getTypeInfo($parent_type, 'dir');
		}
	} else {
		$asset_dirs = Array();
	}

	return $asset_dirs;

}//end find_asset_type_dirs()


/**
* Takes the requested filename and searches back up the directories to find the matching file
* closest to the type of the asset that we are creating or editing
*
* @param string	$file_name	the file to find
*
* @return string
* @access public
*/
function find_edit_interface_file($asset_type, $file_name)
{
	$file_name = 'edit_interface_'.$file_name.'.xml';

	$file = '';
	$asset_dirs = find_asset_type_dirs($asset_type);
	array_push($asset_dirs, SQ_INCLUDE_PATH.'/asset_edit');
	for ($i = 0; $i < count($asset_dirs); $i++) {
		if (file_exists($asset_dirs[$i].'/'.$file_name)) {
			$file = $asset_dirs[$i].'/'.$file_name;
			break;
		}
	}

	if (!$file) {
		trigger_error($file_name.' not found for Asset Type "'.$asset_type.'"', E_USER_WARNING);
		return false;
	}

	return $file;

}//end find_edit_interface_file()


/**
* Find a list of language files to extract from, searching up the
* directories for the closest match in the current language, then running
* through fallbacks (ie. the system's default backend locale)
*
* @param string	$file_name	the file to find
*
* @return Array	an array of file names to potentially parse, most relevant
*				first
* @access public
*/
function find_edit_interface_language_files($asset_type, $file_name, $locale)
{
	$file_name = 'lang_'.$file_name.'.xml';

	$files = Array();
	$asset_dirs = find_asset_type_dirs($asset_type);
	array_push($asset_dirs, SQ_INCLUDE_PATH.'/asset_edit');

	list($lang, $country, $variant) = $GLOBALS['SQ_SYSTEM']->lm->getLocaleParts($locale);

	$lang_dirs = Array(strtolower($lang));
	if (!empty($country)) {
		array_unshift($lang_dirs, strtolower($lang).'/'.strtoupper($country));

		if (!empty($variant)) {
			array_unshift($lang_dirs, strtolower($lang).'/'.strtoupper($country).'/'.$variant);
		}
	}

	for ($i = 0; $i < count($lang_dirs); $i++) {
		for ($j = 0; $j < count($asset_dirs); $j++) {
			if (file_exists($asset_dirs[$j].'/locale/'.$lang_dirs[$i].'/'.$file_name)) {
				$files[] = $asset_dirs[$j].'/locale/'.$lang_dirs[$i].'/'.$file_name;
			}
		}
	}

	return $files;

}//end find_edit_interface_language_files()


/**
* Builds an XML tree for a screen/locale combination that can be cached
*
* @param string	$screen	the screen being built for this asset type
* @param string	$locale	the locale we are generating this screen for
*
* @return object XML_Tree_Node
*/
function build_localised_screen($asset_type, $screen, $locale)
{
	//print '  - Building '.$screen.'.'.$locale."\n";

	$ei_file = find_edit_interface_file($asset_type, $screen);

	// get the XML for the edit interface file
	$ei_input = new XML_Tree($ei_file);
	$to_cache  = &$ei_input->getTreeFromFile();
	if (PEAR::isError($to_cache)) {
		trigger_error('Unable to Read File : '.$ei_file."\n".$to_cache->getMessage()."\n".$to_cache->getUserInfo(), E_USER_WARNING);
		return null;
	}

	if (empty($to_cache->children)) {
		return serialize($to_cache);
	}

	$lang_files = find_edit_interface_language_files($asset_type, $screen, $locale);

	foreach ($lang_files as $lang_file) {

		// get the XML for the edit interface file
		$lang_input = new XML_Tree($lang_file);
		$lang_root  = &$lang_input->getTreeFromFile();
		if (PEAR::isError($lang_root)) {
			trigger_error('Unable to Read File : '.$lang_file."\n".$lang_root->getMessage()."\n".$lang_root->getUserInfo(), E_USER_WARNING);
			continue;
		}

		// work through all the sections
		for ($sec_index = 0; $sec_index < count($lang_root->children); $sec_index++) {
			$xml_section =& $lang_root->children[$sec_index];

			for ($i = 0; $i < count($to_cache->children); $i++) {
				$this_section =& $to_cache->children[$i];

				if ($this_section->attributes['name'] ==
				$xml_section->attributes['name']) {
					break;
				}
			}

			// not found
			if ($i >= count($to_cache->children)) continue;

			// now work through all the fields
			for ($field_index = 0; $field_index < count($xml_section->children); $field_index++) {
				$xml_field =& $xml_section->children[$field_index];

				switch ($xml_field->name) {
					case 'display_name':
						// is a display name already set?
						if (!isset($this_section->attributes['display_name'])) {
							$this_section->attributes['display_name'] = $xml_field->content;
						}
					break;

					case 'note':
						// is a section note already set?
						if (!isset($this_section->attributes['note'])) {
							$this_section->insertChild(null, count($this_section->children), $xml_field->name, $xml_field->content);
						}
					break;

					case 'field':
						// as in the current painting of the interface,
						// the existence of an attribute name means we are
						// accessing an attribute, otherwise we are accessing
						// a function call

						if (empty($xml_field->attributes['attribute'])) {
							// first, look for the function call tag in the language file
							for ($sub_index = 0; $sub_index < count($xml_field->children); $sub_index++) {
								if ($xml_field->children[$sub_index]->name == 'function_call') {
									$xml_paint_field =& $xml_field->children[$sub_index]->children[0];
									break;
								}
							}

							// now, look to see if any of the structure fields match
							for ($i = 0; $i < count($this_section->children); $i++) {
								$this_field =& $this_section->children[$i];
								$paint_field =& $this_field->children[0]->children[0];
								if ($paint_field->name != 'paint_function') continue;
								if ($paint_field->attributes['name'] == $xml_paint_field->attributes['name']) {
									break;
								}
							}

							// not found
							if ($i >= count($this_section->children)) continue;

							// check to see whether we already have a display
							// name or note, because we don't want to double
							// them up
							$has_display_name = false;
							$has_note = false;

							for ($sub_field_index = 0; $sub_field_index < count($this_field->children); $sub_field_index++) {
								$sub_name = $this_field->children[$sub_field_index]->name;
								if ($sub_name == 'display_name') {
									$has_display_name = true;
								}

								if ($sub_name == 'note') $has_note = true;
							}

							for ($sub_index = 0; $sub_index < count($xml_field->children); $sub_index++) {
								$xml_sub_field = $xml_field->children[$sub_index];
								switch ($xml_sub_field->name) {
									case 'display_name':
										$this_field->insertChild(null, 0, $xml_sub_field->name, $xml_sub_field->content);
									break;

									case 'note':
										// want to insert this as second-to-last
										$this_field->insertChild(null, count($this_field->children) - 1, $xml_sub_field->name, $xml_sub_field->content);
									break;

								}
							}

						} else {

							$attr_name = $xml_field->attributes['attribute'];

							for ($i = 0; $i < count($this_section->children); $i++) {
								$this_field =& $this_section->children[$i];
								if (array_get_index($this_field->attributes, 'attribute', '') == $attr_name) {
									break;
								}
							}

							// not found
							if ($i >= count($this_section->children)) continue;

							// check to see whether we already have a display
							// name or note, because we don't want to double
							// them up
							$has_display_name = false;
							$has_note = false;

							for ($sub_field_index = 0; $sub_field_index < count($this_field->children); $sub_field_index++) {
								$sub_name = $this_field->children[$sub_field_index]->name;
								if ($sub_name == 'display_name') {
									$has_display_name = true;
								}

								if ($sub_name == 'note') $has_note = true;
							}

							for ($sub_index = 0; $sub_index < count($xml_field->children); $sub_index++) {
								$xml_sub_field = $xml_field->children[$sub_index];
								switch ($xml_sub_field->name) {
									case 'display_name':
										if (!$has_display_name) {
											$this_field->insertChild(null, 0, $xml_sub_field->name, $xml_sub_field->content);
										}
									break;

									case 'note':
										// want to insert this as second-to-last
										if (!$has_note) {
											$this_field->insertChild(null, count($this_field->children) - 1, $xml_sub_field->name, $xml_sub_field->content);
										}
									break;

								}
							}

						}

					break;

				}//end switch

			}

		}

	}

	return $to_cache;

}//end build_localised_screen()


/**
* Builds an XML tree for a screen/locale combination that can be cached
*
* @param string	$screen	the screen being built for this asset type
* @param string	$locale	the locale we are generating this screen for
*
* @return object XML_Tree_Node
*/
function build_localised_static_screen($asset_type, $screen, $locale)
{
	//print '  - Building '.$screen.'.'.$locale."\n";

	$ei_file = find_edit_interface_file($asset_type, $screen);
	// get the XML for the edit interface file
	$ei_input = new XML_Tree($ei_file);
	$to_cache  = &$ei_input->getTreeFromFile();
	if (PEAR::isError($to_cache)) {
		trigger_error('Unable to Read File : '.$ei_file."\n".$to_cache->getMessage()."\n".$to_cache->getUserInfo(), E_USER_WARNING);
		return null;
	}

	if (empty($to_cache->children)) {
		return serialize($to_cache);
	}

	if ($asset_type == 'system_management_folder') {
		bam($to_cache);
	}

	$lang_files = find_edit_interface_language_files($asset_type, $screen, $locale);

	foreach ($lang_files as $lang_file) {

		// get the XML for the edit interface file
		$lang_input = new XML_Tree($lang_file);
		$lang_root  = &$lang_input->getTreeFromFile();
		if (PEAR::isError($lang_root)) {
			trigger_error('Unable to Read File : '.$lang_file."\n".$lang_root->getMessage()."\n".$lang_root->getUserInfo(), E_USER_WARNING);
			continue;
		}

		if ($asset_type == 'system_management_folder') {
			bam($lang_root);
		}

		// work through all the sections
		for ($sec_index = 0; $sec_index < count($lang_root->children); $sec_index++) {
			$xml_section =& $lang_root->children[$sec_index];

			for ($i = 0; $i < count($to_cache->children); $i++) {
				$this_section =& $to_cache->children[$i];

				if ($this_section->attributes['name'] ==
				$xml_section->attributes['name']) {
					break;
				}
			}

			// not found
			if ($i >= count($to_cache->children)) continue;

			// now work through all the fields
			for ($field_index = 0; $field_index < count($xml_section->children); $field_index++) {
				$xml_field =& $xml_section->children[$field_index];

				switch ($xml_field->name) {
					case 'display_name':
						// is a display name already set?
						if (!isset($this_section->attributes['display_name'])) {
							$this_section->attributes['display_name'] = $xml_field->content;
						}
					break;

					case 'note':
						// is a section note already set?
						if (!isset($this_section->attributes['note'])) {
							$this_section->insertChild(null, count($this_section->children), $xml_field->name, $xml_field->content);
						}
					break;

					case 'field':
						// as in the current painting of the interface,
						// the existence of an attribute name means we are
						// accessing an attribute, otherwise we are accessing
						// a function call

						if (empty($xml_field->attributes['code'])) {
							trigger_error('Static screen sections need a code for each field', E_USER_WARNING);
						} else {

							$code_name = $xml_field->attributes['code'];

							for ($i = 0; $i < count($this_section->children); $i++) {
								$this_field =& $this_section->children[$i];
								if (array_get_index($this_field->attributes, 'code', '') == $code_name) {
									break;
								}
							}

							// not found
							if ($i >= count($this_section->children)) continue;

							// check to see whether we already have a display
							// name or note, because we don't want to double
							// them up
							$has_display_name = false;
							$has_note = false;

							for ($sub_field_index = 0; $sub_field_index < count($this_field->children); $sub_field_index++) {
								$sub_name = $this_field->children[$sub_field_index]->name;
								if ($sub_name == 'display_name') {
									$has_display_name = true;
								}

								if ($sub_name == 'note') $has_note = true;
							}

							for ($sub_index = 0; $sub_index < count($xml_field->children); $sub_index++) {
								$xml_sub_field = $xml_field->children[$sub_index];
								switch ($xml_sub_field->name) {
									case 'display_name':
										if (!$has_display_name) {
											$this_field->insertChild(null, 0, $xml_sub_field->name, $xml_sub_field->content);
										}
									break;

									case 'note':
										// want to insert this as last
										if (!$has_note) {
											$this_field->insertChild(null, count($this_field->children), $xml_sub_field->name, $xml_sub_field->content);
										}
									break;

								}
							}

						}

					break;

				}//end switch

			}

		}

	}

	return $to_cache;

}//end build_localised_static_screen()


function find_string_language_files($asset_dirs, $locale, $file='strings')
{
	$file_name = 'lang_'.$file.'.xml';

	$files = Array();

	list($lang, $country, $variant) = $GLOBALS['SQ_SYSTEM']->lm->getLocaleParts($locale);

	$lang_dirs = Array(strtolower($lang));
	if (!empty($country)) {
		array_unshift($lang_dirs, strtolower($lang).'/'.strtoupper($country));

		if (!empty($variant)) {
			array_unshift($lang_dirs, strtolower($lang).'/'.strtoupper($country).'/'.$variant);
		}
	}

	for ($i = 0; $i < count($lang_dirs); $i++) {
		for ($j = 0; $j < count($asset_dirs); $j++) {
			if (file_exists($asset_dirs[$j].'/locale/'.$lang_dirs[$i].'/'.$file_name)) {
				$files[] = $asset_dirs[$j].'/locale/'.$lang_dirs[$i].'/'.$file_name;
			}
		}
	}

	return $files;

}//end find_string_language_files()


/**
* Builds the locale error file for a certain locale
*
* @param string	$locale	the locale to be compiled
*
* @return void
* @access public
*/
function build_locale_string_file($locale)
{
	$asset_types = $GLOBALS['SQ_SYSTEM']->am->getAssetTypes();
	$packages = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	$files_to_parse = Array(
						'core'		=> Array(),
						'packages'	=> Array(),
						'assets'	=> Array(),
					  );

	$strings = Array();

	// run through the core
	$asset_dirs = Array(SQ_SYSTEM_ROOT.'/core');
	$files_to_parse['core'] = find_string_language_files($asset_dirs, $locale);


	// run through each installed package
	foreach ($packages as $package) {
		$package_name = $package['code_name'];

		if ($package_name == '__core__') {
			$asset_dirs = Array(SQ_CORE_PACKAGE_PATH);
		} else {
			$asset_dirs = Array(SQ_PACKAGES_PATH.'/'.$package_name);
		}

		$files_to_parse['packages'][$package_name] = find_string_language_files($asset_dirs, $locale);
	}

	// run through each installed asset
	foreach ($asset_types as $asset_type) {
		$type_code = $asset_type['type_code'];
		$asset_dirs =& find_asset_type_dirs($type_code);

		$files_to_parse['assets'][$type_code] = find_string_language_files($asset_dirs, $locale);
	}

	$strings = Array();
	$js_strings = Array();
	$java_strings = Array();

	foreach ($files_to_parse['core'] as $file) {
		// grab the strings
		list($ex_strings, $ex_js_strings, $ex_java_strings) = extract_strings_from_xml($file, 'strings', 'string', 'source');
		$strings = array_merge($strings, $ex_strings);
		$js_strings = array_merge($js_strings, $ex_js_strings);
		$java_strings = array_merge($java_strings, $ex_java_strings);
	}

	if (!empty($strings)) {
		create_directory(SQ_DATA_PATH.'/private/system/core');
		string_to_file(serialize($strings), SQ_DATA_PATH.'/private/system/core/strings.'.$locale);
	}

	foreach ($files_to_parse['packages'] as $package_name => $files) {
		$strings = Array();
		foreach ($files as $file) {
			list($ex_strings, $ex_js_strings, $ex_java_strings) = extract_strings_from_xml($file, 'strings', 'string', 'source');
			$strings = array_merge($strings, $ex_strings);
			$js_strings = array_merge($js_strings, $ex_js_strings);
			$java_strings = array_merge($java_strings, $ex_java_strings);
		}

		if ($package_name == '__core__') {
			$package_dir = Array(SQ_CORE_PACKAGE_PATH);
		} else {
			$package_dir = Array(SQ_PACKAGES_PATH.'/'.$package_name);
		}
		if (!empty($strings)) {
			create_directory(SQ_DATA_PATH.'/private/packages/'.$package_name);
			string_to_file(serialize($strings), SQ_DATA_PATH.'/private/packages/'.$package_name.'/strings.'.$locale);
		}
	}

	foreach ($files_to_parse['assets'] as $type_code => $files) {
		$strings = Array();
		foreach ($files as $file) {
			list($ex_strings, $ex_js_strings, $ex_java_strings) = extract_strings_from_xml($file, 'strings', 'string', 'source');
			$strings = array_merge($strings, $ex_strings);
			$js_strings = array_merge($js_strings, $ex_js_strings);
			$java_strings = array_merge($java_strings, $ex_java_strings);
		}

		$asset_dir = $asset_types[$type_code]['dir'];
		if (!empty($strings)) {
			create_directory(SQ_DATA_PATH.'/private/asset_types/'.$type_code);
			string_to_file(serialize($strings), SQ_DATA_PATH.'/private/asset_types/'.$type_code.'/strings.'.$locale);
		}
	}

	// only one JavaScript and one Java file will be kept, in Core
	if (!empty($js_strings)) {
		create_directory(SQ_DATA_PATH.'/public/system/core');

		$js_file = 'SQ_CURRENT_LOCALE = "'.$locale.'";'."\n".
					'translated_strings["'.$locale.'"] = new Array();'."\n";

		foreach ($js_strings as $string_code => $string) {
			$string = str_replace("\n", '\\n', $string);
			$string = str_replace('"', '\\"', $string);
			$js_file .= 'translated_strings["'.$locale.'"]["'.$string_code.'"] = "'.$string.'";'."\n";
		}

		string_to_file($js_file, SQ_DATA_PATH.'/public/system/core/js_strings.'.$locale.'.js');
	}

	// Similar for Java file, BUT to take advantage of i18n stuff in Java, we
	// need to change the replacements to Java 'MessageFormat' format
	// eg. '%1$s' => '{0}', '%2$s' => '{1}', etc.
	if (!empty($java_strings)) {
		create_directory(SQ_DATA_PATH.'/private/system/core');

		$java_file = '';
		foreach ($java_strings as $string_code => $string) {
			// replace single parameters with {0}
			$string = preg_replace('|%s|', '{0}', $string);

			// iterate through the string until there's no more replacements
			while (preg_match('|%(\d*)\\$s|', $string, $match, PREG_OFFSET_CAPTURE)) {
				// build the Java-style argument and shove it into the string
				$new_arg = '{'.((int)$match[1][0]-1).'}';
				$string = substr_replace($string, $new_arg, $match[0][1], strlen($match[1][0]) + 3);
			}

			$java_file .= $string_code.' = '.$string."\n";
		}

		string_to_file($java_file, SQ_DATA_PATH.'/private/system/core/java_strings_'.$locale.'.properties');
	}

}//end build_locale_string_file()


/**
* Builds the locale error file for a certain locale
*
* Error files are expected to include one for each package, one for the
*
* @param string	$locale	the locale to be compiled
*
* @return void
* @access public
*/
function build_locale_error_file($locale)
{
	$packages = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	$files_to_parse = Array(
						'core'		=> Array(),
						'packages'	=> Array(),
					  );

	$strings = Array();

	// run through the core
	$asset_dirs = Array(SQ_SYSTEM_ROOT.'/core');
	$files_to_parse['core'] = find_string_language_files($asset_dirs, $locale, 'errors');

	// run through each installed package
	foreach ($packages as $package) {
		$package_name = $package['code_name'];

		if ($package_name == '__core__') {
			$asset_dirs = Array(SQ_CORE_PACKAGE_PATH);
		} else {
			$asset_dirs = Array(SQ_PACKAGES_PATH.'/'.$package_name);
		}

		$files_to_parse['packages'][$package_name] = find_string_language_files($asset_dirs, $locale, 'errors');
	}

	$strings = Array();

	foreach ($files_to_parse['core'] as $file) {
		$strings = array_merge(array_get_index($strings, 'core', Array()), extract_errors_from_xml($file, 'errors', 'error', 'code'));
	}

	if (!empty($strings)) {
		create_directory(SQ_DATA_PATH.'/private/system/core');
		string_to_file(serialize($strings), SQ_DATA_PATH.'/private/system/core/errors.'.$locale);
	}

	foreach ($files_to_parse['packages'] as $package_name => $files) {
		$strings = Array();
		foreach ($files as $file) {
			$strings = array_merge($strings, extract_errors_from_xml($file, 'errors', 'error', 'code'));
		}

		if ($package_name == '__core__') {
			$package_dir = Array(SQ_CORE_PACKAGE_PATH);
		} else {
			$package_dir = Array(SQ_PACKAGES_PATH.'/'.$package_name);
		}
		if (!empty($strings)) {
			create_directory(SQ_DATA_PATH.'/private/packages/'.$package_name);
			string_to_file(serialize($strings), SQ_DATA_PATH.'/private/packages/'.$package_name.'/errors.'.$locale);
		}
	}

}//end build_locale_error_file()


/**
* Builds the locale internal messages file for a certain locale
*
* @param string	$locale	the locale to be compiled
*
* @return void
* @access public
*/
function build_locale_internal_messages_file($locale)
{
	$packages = $GLOBALS['SQ_SYSTEM']->getInstalledPackages();

	$files_to_parse = Array(
						'core'		=> Array(),
						'packages'	=> Array(),
					  );

	$strings = Array();

	// run through the core
	$asset_dirs = Array(SQ_SYSTEM_ROOT.'/core');
	$files_to_parse['core'] = find_string_language_files($asset_dirs, $locale, 'messages');

	// run through each installed package
	foreach ($packages as $package) {
		$package_name = $package['code_name'];

		if ($package_name == '__core__') {
			$asset_dirs = Array(SQ_CORE_PACKAGE_PATH);
		} else {
			$asset_dirs = Array(SQ_PACKAGES_PATH.'/'.$package_name);
		}

		$files_to_parse['packages'][$package_name] = find_string_language_files($asset_dirs, $locale, 'messages');
	}

	$strings = Array();

	foreach ($files_to_parse['core'] as $file) {
		$strings = array_merge(array_get_index($strings, 'core', Array()), extract_internal_messages($file));

		if (!empty($strings)) {
			create_directory(SQ_DATA_PATH.'/private/system/core');
			string_to_file(serialize($strings), SQ_DATA_PATH.'/private/system/core/internal_messages.'.$locale);
		}
	}

	foreach ($files_to_parse['packages'] as $package_name => $files) {
		$strings = Array();
		foreach ($files as $file) {
			$strings = array_merge($strings, extract_internal_messages($file));
		}

		if ($package_name == '__core__') {
			$package_dir = Array(SQ_CORE_PACKAGE_PATH);
		} else {
			$package_dir = Array(SQ_PACKAGES_PATH.'/'.$package_name);
		}
		if (!empty($strings)) {
			create_directory(SQ_DATA_PATH.'/private/packages/'.$package_name);
			string_to_file(serialize($strings), SQ_DATA_PATH.'/private/packages/'.$package_name.'/internal_messages.'.$locale);
		}
	}

}//end build_locale_internal_messages_file()


/**
 *
 */
function &extract_child_nodes_from_xml($file, $root_element, $child_element, $key_attribute)
{
	$extracted_strings = Array();

	$input = new XML_Tree($file);
	$root  = &$input->getTreeFromFile();
	if (PEAR::isError($root)) {
		trigger_error('Unable to Read File : '.$file."\n".$root->getMessage()."\n".$root->getUserInfo(), E_USER_WARNING);
		return Array();
	}

	if ($root->name != $root_element) {
		trigger_error('XML file "'.$file.'" does not appear to be valid - expecting "'.$root_element.'" as document element, found "'.$root->name.'"', E_USER_WARNING);
		return Array();
	}

	foreach ($root->children as $string_node) {
		if ($string_node->name != $child_element) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - expecting node "'.$child_element.'", found "'.$string_node->name.'"', E_USER_WARNING);
			return Array();
		}

		if (!isset($string_node->attributes[$key_attribute])) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - missing attribute "'.$key_attribute.'" in string node', E_USER_WARNING);
			return Array();
		}

		}//end foreach string_node

	return $root->children;

}//end extract_child_nodes_from_xml()


/**
 *
 */
function extract_strings_from_xml($file, $root_element, $child_element, $key_attribute)
{
	$extracted_strings = Array();
	$js_strings = Array();
	$java_strings = Array();

	$children = extract_child_nodes_from_xml($file, $root_element, $child_element, $key_attribute);

	foreach ($children as $string_node) {
		if ($string_node->name != $child_element) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - expecting node "'.$child_element.'", found "'.$string_node->name.'"', E_USER_WARNING);
			return Array();
		}

		if (!isset($string_node->attributes[$key_attribute])) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - missing attribute "'.$key_attribute.'" in string node', E_USER_WARNING);
			return Array();
		}

		$source_code = $string_node->attributes[$key_attribute];
		$translation = html_entity_decode($string_node->content);

		// have it already been set in this file?
		if (isset($extracted_strings[$source_code])) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - detected duplicate code "'.$source_code.'"', E_USER_WARNING);
			return Array(Array(), Array(), Array());
		} else if (empty($translation)) {
			trigger_error('Skipping translation for code "'.$source_code.'" as the translation appears to be empty', E_USER_NOTICE);
		} else if (preg_match_all('|%s|', $translation, $matches) > 1) {
			trigger_error('Skipping translation for code "'.$source_code.'"; it has multiple occurrences of unpositioned "%s" - use positioned replacements (eg. "%1$s") when you have more than one', E_USER_WARNING);
		} else {

			$extracted_strings[$source_code] = $translation;

			if (isset($string_node->attributes['js']) && ($string_node->attributes['js'] == 1)) {
				$js_strings[$source_code] =& $extracted_strings[$source_code];
			}
			if (isset($string_node->attributes['java']) && ($string_node->attributes['java'] == 1)) {
				$java_strings[$source_code] =& $extracted_strings[$source_code];
			}
		}

	}//end foreach string_node

	return Array($extracted_strings, $js_strings, $java_strings);

}//end extract_strings_from_xml()


/**
 *
 */
function extract_errors_from_xml($file, $root_element, $child_element, $key_attribute)
{
	$extracted_strings = Array();

	$children = extract_child_nodes_from_xml($file, $root_element, $child_element, $key_attribute);

	foreach ($children as $string_node) {
		if ($string_node->name != $child_element) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - expecting node "'.$child_element.'", found "'.$string_node->name.'"', E_USER_WARNING);
			return Array();
		}

		if (!isset($string_node->attributes[$key_attribute])) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - missing attribute "'.$key_attribute.'" in string node', E_USER_WARNING);
			return Array();
		}

		$source_code = $string_node->attributes[$key_attribute];
		$translation = html_entity_decode($string_node->content);

		// have it already been set in this file?
		if (isset($extracted_strings[$source_code])) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - detected duplicate code "'.$source_code.'"', E_USER_WARNING);
			return Array(Array(), Array(), Array());
		} else if (empty($translation)) {
			trigger_error('Skipping translation for code "'.$source_code.'" as the translation appears to be empty', E_USER_NOTICE);
		} else if (preg_match_all('|%s|', $translation, $matches) > 1) {
			trigger_error('Skipping translation for code "'.$source_code.'"; it has multiple occurrences of unpositioned "%s" - use positioned replacements (eg. "%1$s") when you have more than one', E_USER_WARNING);
		} else {
			$extracted_strings[$source_code] = $translation;
		}

	}//end foreach string_node

	return $extracted_strings;

}//end extract_errors_from_xml()


/**
 *
 */
function extract_internal_messages($file)
{
	$root_element = 'messages';
	$child_element = 'message';
	$key_attribute = 'type';
	$extracted_messages = Array();

	$children = extract_child_nodes_from_xml($file, $root_element, $child_element, $key_attribute);

	foreach ($children as $string_node) {
		if ($string_node->name != $child_element) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - expecting node "'.$child_element.'", found "'.$string_node->name.'"', E_USER_WARNING);
			return Array();
		}

		if (!isset($string_node->attributes[$key_attribute])) {
			trigger_error('XML file "'.$file.'" does not appear to be valid - missing attribute "'.$key_attribute.'" in string node', E_USER_WARNING);
			return Array();
		}

		$source_code = $string_node->attributes[$key_attribute];
		$translation = Array();

		foreach ($string_node->children as $sub_node) {
			if (($sub_node->name == 'subject') || ($sub_node->name == 'body')) {
				$translation[$sub_node->name] = html_entity_decode($sub_node->content);
			}
		}

		if (!isset($translation['subject']) || !isset($translation['body'])) {
			// we don't have enough stuff?
			trigger_error('XML file "'.$file.'" does not appear to be valid - internal message type "'.$source_code.'" does not seem to have a subject and body', E_USER_WARNING);
		} else if (isset($extracted_messages[$source_code])) {
			// have it already been set in this file?
			trigger_error('XML file "'.$file.'" does not appear to be valid - detected duplicate message type "'.$source_code.'"', E_USER_WARNING);
			return Array();
		} else if (empty($translation)) {
			trigger_error('Skipping translation for code "'.$source_code.'" as the translation appears to be empty', E_USER_NOTICE);
		} else {
			// replace \n with a new line, but not \\n
			$extracted_messages[$source_code]['subject'] = $translation['subject'];
			$extracted_messages[$source_code]['body']    = $translation['body'];
		}

	}//end foreach string_node

	return $extracted_messages;

}//end extract_internal_messages()

?>
